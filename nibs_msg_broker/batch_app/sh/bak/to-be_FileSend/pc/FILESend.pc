/****************************************************************************/
/* 01. 프로그램명 		: {FILESend.pc}		                           		*/
/* 02. 작  성  자       	: {방혜진}                                          	*/
/* 03. 작 성 일 자      	: {2006/08/29}                                      */
/* 04. 프로그램기능     	: {}												*/
/* 05. 입력FILE         	: 													*/
/* 06. 출력FILE         	:													*/
/* 07. 입력DATA HEADER  	: {}                                                */
/* 08. 출력DATA HEADER  	: {}                                                */
/* 09. 프로그램TYPE     	: {LIBRARY}                                         */
/* 10. LINK LIBRARY     : {}                                                */
/* 11. 작업주기         	: {0건/0일}                                         	*/
/* 12. TR-CODE          : {}                                                */
/* 13. 사용부서         	: {전산부}                                          	*/
/* 14. POWER SERVICE    : {0}                                               */
/* 15. REMARKS 사항     	: {}                                                */
/****************************************************************************/

/****************************************************************************/
/* SYSTEM HEADER 정의                                                       	*/
/****************************************************************************/
#include	<stdio.h>
#include	<string.h>
#include	<stdlib.h>
#include	<errno.h>
#include	<signal.h>
#include	<fcntl.h>
#include	<netdb.h>
#include	<math.h>
#include	<sys/ioctl.h>
#include	<sys/types.h>
#include	<netinet/in.h>
#include	<arpa/inet.h>

/****************************************************************************/
/* 사용자 HEADER 정의                                                       */
/****************************************************************************/
#include    "../include/dberrno.h"
#include    "../include/commdef.h"

#define APP_NAME	"FILESend"
#define	LOG_NAME	"filesend"

EXEC SQL INCLUDE SQLCA;

/****************************************************************************/
/* FUNCTION PROTO TYPE 정의                                                 */
/****************************************************************************/
void    CleanUp(int Sig);

int PutOrgTranFile(char *pDate, char *pOrgCd);
int GetCNTranData(char *pDate, char *pFileName);
int GetCNMacData(char *pTransDate, char *pFileName);

int GetBCTranData(char *pDate, char *pFileName);
int GetBCMacData(char *pTransDate, char *pFileName);
int GetCUTranData(char *pDate, char *pFileName);
int GetCityTranData(char *pDate, char *pFileName);
int GetLGTranData(char *pDate, char *pFileName);
int GetLCTranData(char *pDate, char *pFileName);
int GetNongHTranData(char *pDate, char *pFileName);
int GetNongHTranData_NEW(char *pDate, char *pFileName);
int GetNongHMacData(char *pTransDate, char *pFileName);
int GetNongHBrandMacData(char *pTransDate, char *pFileName);
int GetHNetNewTranData(char *pDate, char *pFileName);
int GetHNetTranData(char *pDate, char *pFileName);
int GetCommonTranData(char *pTransDate, char *pOrgCd, char *pFileName);
int GetKiupTranData(char *pTransDate, char *pOrgCd, char *pFileName);
int GetKBSTTranData(char *pTransDate, char *pOrgCd, char *pFileName);
/*int GetCommonImsiData(char *pTransDate, char *pOrgCd, char *pFileName);*/
int GetKETranData(char *pTransDate, char *pOrgCd, char *pFileName);
int GetSmartTranData(char *pTransDate, char *pFileName);
int GetSmartImsiTranData(char *pTransDate, char *pFileName);
int GetHITranData(char *pDate, char *pFileName);
int GetCHTranData(char *pDate, char *pFileName);
int GetKFTCTranData(char *pDate, char *pFileName);
int GetGiftCardInfoData(char *pDate, char *pPathName, char * pRtnFileName);

int GetSHTranData(char *pTransDate, char *pFileName, char * pDealType);
int GetSCTranData(char *pTransDate, char *pFileName);
int GetSuHTranData(char *pTransDate, char *pFileName);
int GetSuHMacData(char *pTransDate, char *pFileName);
int ReadSmartFileData( char * pFile, struct FILE_READ_DATA * psuFileRead );

int GetNongHTranData_dasi(char *pTransDate, char *pFileName);

/****************************************************************************/
/* 사용자 외부변수 및 공용변수 정의                                         */
/****************************************************************************/
varchar huid[20];
varchar hpid[20];

short   logflg;							/* log function(logger) on/off flag */
int     logdev;							/* log function(logger) file desc.  */

pid_t	process_id = 0;

#define MAX_ORG_CNT	29

struct  FILE_READ_DATA  {
	char    szDealDate[8+1];
	char	szDealNo[12+1];
	char	szOwnerType[2+1];
	char	szDealSeqNo[10+1];
	char	szPreAmt[10+1];
	char	szConfirmNm[10+1];
};
#define FILE_READ_DATA_LEN  sizeof(struct FILE_READ_DATA)

void main(int argc, char *argv[])
{
	long	lPrevDate;
	int		i;
	char	szTransDate[100];
	char	szOrgCd[4];
	char	szaryOrg[MAX_ORG_CNT][4] = {
		"0BC",
		"1BC",
		"0CN",
		"0CU",
		"0HM",
		"0LG",
		"0LC",
		"B11",
		"181",
		"003",
		"044",
		"031",
		"020",
		"023",
		"011",
		"012",
		"004",
		/*"0KS",==>서비스종료*/
		"0HI",
		"A11",
		"Z11",
		"1CN",
		"0CH",
		"088",
		"488",
		"0SC",
		"A07",
		"007",
		"000",
		"0GV"
	};

/*
	if ( argc != 2 )
	{
		printf( "Usage : MakeOrgTranFile [calc_date]\n" );
		exit(0);
	}
*/

printf("[%-*s][%02.02f][%04d]\n", 5, "", 2.3, 12);
	/* 인자를 쓰지 않는다면 당일 날자로 */

	memset( szTransDate, 0x00, sizeof(szTransDate) );
	memset( szOrgCd, 0x00, sizeof(szOrgCd) );

	if ( argc != 2 )
	{
		sprintf(szTransDate, "%08ld", GetCurDate() );
	}
	else
	{
		if(strlen(argv[1]) < 8)
		{
			printf( "Usage : MakeOrgTranFile [calc_date(8)+orgcd(3)]\n" );
			exit(0);
		}
		else
		{
			strncpy(szTransDate, argv[1], 8);

			if( (strlen(argv[1]) - 8) == 3 )
			{
				strncpy(szOrgCd, &argv[1][8], strlen(argv[1]) - 8 );
			}
		}

	}

	if ( fnCheckApplState( APP_NAME ) < 0 )
	{
		printf( "[%s]Appl is already started ... Exit\n\n", APP_NAME );
		exit(0);
	}

	lPrevDate = GetCurDate();
	/* log 파일 형식 지정 LOG - text type HEX - hexa type */
	logflg = LOG;
	if ( fnCheckLogFile( LOG_NAME ) < 0 )
	{
		printf( ">>> [main] log file create fail\n");
		/* LogFile Error 이라도 작업 진행 */
	}
	/*- LOG FILE 처리 ------------------------------------------------------*/

		char	szDBUser[50];
	char	szDBPwd[50];
	char	szDBSID[50];
	char 	hDBConn[100];

	memset((char *)szDBUser	, 	(int)0x00, sizeof(szDBUser	));
	memset((char *)szDBPwd	, 	(int)0x00, sizeof(szDBPwd	));
	memset((char *)szDBSID	, 	(int)0x00, sizeof(szDBSID	));

	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)"DB_USER=", szDBUser ) < 0 )
	{
		printf( "main : rd_cnfg_pram DB USER Get Error \n" );
   		exit(0);
	}

	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)"DB_PWD=", szDBPwd ) < 0 )
	{
		printf( "main : rd_cnfg_pram DB PWD Get Error \n" );
   		exit(0);
	}

	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)"DB_SID=", szDBSID ) < 0 )
	{
		printf( "main : rd_cnfg_pram DB SID Get Error \n" );
   		exit(0);
	}

	memset( hDBConn, 0x00, sizeof( hDBConn ) );

	sprintf( hDBConn, "%s/%s@%s", szDBUser, szDBPwd, szDBSID );

	EXEC SQL CONNECT :hDBConn;

	if ( sqlca.sqlcode != DB_SUCCESS )
	{
		logger( "Connect Err: %.100s\n", SqlErrMsg );
		CleanUp(0);
	}

	if( szOrgCd[0] == 0x00 )
	{
		for( i = 0 ; i < MAX_ORG_CNT; i++ )
		{
			memcpy( szOrgCd, szaryOrg[i], 3 );

			/* 전체실행 예외기관 부분 														 */
			/* 금융결제원(KFTC)의 경우, 전체실행 시간인 01:30에 데이터가 없으므로, 제외한다. */
			if ( memcmp( szOrgCd, "000", 3 ) == 0 ) { continue; }

			PutOrgTranFile(szTransDate, szOrgCd);
		}
	}
	else
	{
		PutOrgTranFile(szTransDate, szOrgCd);
	}
/*
	PutOrgTranFile(szTransDate, "0BC");
	PutOrgTranFile(szTransDate, "0CN");
	PutOrgTranFile(szTransDate, "0CU");
	PutOrgTranFile(szTransDate, "0HM");
	PutOrgTranFile(szTransDate, "0LG");
	PutOrgTranFile(szTransDate, "B11");
	PutOrgTranFile(szTransDate, "181");
	PutOrgTranFile(szTransDate, "003");
	PutOrgTranFile(szTransDate, "044");
	PutOrgTranFile(szTransDate, "031");
	PutOrgTranFile(szTransDate, "020");
	PutOrgTranFile(szTransDate, "023");
	PutOrgTranFile(szTransDate, "011");
	PutOrgTranFile(szTransDate, "012");
	PutOrgTranFile(szTransDate, "081");
*/
	logger( ">>> [main] 작업완료\n");

	exit(0);
}

/****************************************************************************/
/* 01. FUNCTION	ID      : {CleanUp}                                       */
/* 02. 작  성  자       	: {방혜진}                                          	*/
/* 03. 작 성 일 자      	: {2006/07/13}                                      */
/* 04. 프로그램기능     	: {해당 Sock Close, Log File Close, Program End}		*/
/* 05. 입력FILE         	: 													*/
/* 06. 출력FILE         	:													*/
/* 07. Return	값      	: {}												*/
/* 08. REMARKS 사항     	: {}                                               	*/
/****************************************************************************/
void    CleanUp(int Sig)
{
    logger("Clena Up Sig = %d\n\n", Sig);
    LogClose();
	sleep(1);
    exit(0);
}

int PutOrgTranFile(char *pDate, char *pOrgCd)
{

	char	szSrcPath[1024];
	char	szDestPath[1024];
	char	szHost[200];
	char	szID[20];
	char	szPwd[20];
	char	szFileName[100];
	char	szBackFileName[100];
	char	szFullFile[500];
	char	szFtpScript[500];
	char	szFtpScriptChk[500];
	int		ftpsuccess;
	int		nRtn = -1;
	long	retval,	newlimit;

	FILE *	ftp;

	memset((char *)szSrcPath, 	(int)0x00, sizeof(szSrcPath));
	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)FTP_SRC_PATH, szSrcPath ) < 0 )
	{
		logger( "main : rd_cnfg_pram FTP_SRC_PATH Get Error = [%s]\n", szSrcPath );
   		CleanUp(0);
	}

	memset((char *)szDestPath, 	(int)0x00, sizeof(szDestPath));
	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)FTP_DEST_PATH, szDestPath ) < 0 )
	{
		logger( "main : rd_cnfg_pram FTP_DEST_PATH Get Error = [%s]\n", szDestPath );
   		CleanUp(0);
	}

	memset((char *)szHost, 	(int)0x00, sizeof(szHost));
	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)FTP_HOST_IP, szHost ) < 0 )
	{
		logger( "main : rd_cnfg_pram FTP_FILE_IP Get Error = [%s]\n", szHost );
   		CleanUp(0);
	}

	memset((char *)szID, 	(int)0x00, sizeof(szID));
	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)FTP_HOST_UNAME, szID ) < 0 )
	{
		logger( "main : rd_cnfg_pram FTP_HOST_UNAME Get Error = [%s]\n", szID );
   		CleanUp(0);
	}

	memset((char *)szPwd, 	(int)0x00, sizeof(szPwd));
	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)FTP_HOST_PWD, szPwd ) < 0 )
	{
		logger( "main : rd_cnfg_pram FTP_HOST_PWD Get Error = [%s]\n", szPwd );
   		CleanUp(0);
	}

	memset((char *)szFileName, 	(int)0x00, sizeof(szFileName));

	sprintf(szFileName, "S%s%03s", pDate, pOrgCd);

	memset((char *)szFullFile, 	(int)0x00, sizeof(szFullFile));
	sprintf(szFullFile, "%s/%s", szSrcPath, szFileName);

/*
	if(GetCNTranData(pDate, "CN", szFullFile) < 0)
	{
		logger( "file 생성 실패 [%s]\n", szFileName );
		CleanUp(0);
	}
*/

	logger("File 생성 Start [%s]-TransDate[%s], OrgCd[%s]\n", szFileName, pDate, pOrgCd);

	if( strncmp(pOrgCd, "0BC", 3) == 0 )
	{
		nRtn = GetBCTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "1BC", 3) == 0 )
	{
		nRtn = GetBCMacData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "0CN", 3) == 0 )
	{
		nRtn = GetCNTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "1CN", 3) == 0 )
	{
		nRtn = GetCNMacData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "0CU", 3) == 0 )
	{
		nRtn = GetCUTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "0HM", 3) == 0 )
	{
		nRtn = GetCityTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "0LG", 3) == 0 )
	{
		nRtn = GetLGTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "0LC", 3) == 0 )
	{
		nRtn = GetLCTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "B11", 3) == 0 )
	{
		nRtn = GetNongHTranData_NEW(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "A11", 3) == 0 )
	{
		nRtn = GetNongHMacData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "Z11", 3) == 0 )
	{
		nRtn = GetNongHBrandMacData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "181", 3) == 0 )
	{
		nRtn = GetHNetNewTranData(pDate, szFullFile);
		/*
		nRtn = GetHNetTranData(pDate, szFullFile);
		*/

	}
	else if( strncmp(pOrgCd, "044", 3) == 0 )
	{
		nRtn = GetKETranData(pDate, pOrgCd, szFullFile);
	}
/*2013.09.03 서비스 종료
	else if( strncmp(pOrgCd, "0KS", 3) == 0 )
	{
		nRtn = GetSmartTranData(pDate, szFullFile);
		nRtn = GetSmartImsiTranData(pDate, szFullFile);
	}
*/	
	else if( strncmp(pOrgCd, "004", 3) == 0 )
	{
		nRtn = GetKBSTTranData(pDate, pOrgCd, szFullFile);
	}
	else if( strncmp(pOrgCd, "003", 3) == 0 )
	{
		nRtn = GetKiupTranData(pDate, pOrgCd, szFullFile);
	}
	else if( strncmp(pOrgCd, "031", 3) == 0 ||
			 /*strncmp(pOrgCd, "003", 3) == 0 ||*/
			 strncmp(pOrgCd, "020", 3) == 0 ||
			 strncmp(pOrgCd, "023", 3) == 0 ||
			 strncmp(pOrgCd, "011", 3) == 0 ||
			 strncmp(pOrgCd, "012", 3) == 0 )
	{
		nRtn = GetCommonTranData(pDate, pOrgCd, szFullFile);
	}
	else if( strncmp(pOrgCd, "0HI", 3) == 0 )
	{
		nRtn = GetHITranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "0CH", 3) == 0 ) /* 농협카드 */
	{
		nRtn = GetCHTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "088", 3) == 0 ) /* 신한은행 출금FILE*/
	{
		nRtn = GetSHTranData(pDate, szFullFile, "0");	/* 출금FILE 생성 */
	}
	else if( strncmp(pOrgCd, "488", 3) == 0 ) /* 신한은행 이체FILE*/
	{
		nRtn = GetSHTranData(pDate, szFullFile, "4");	/* 이체FILE 생성 */
	}
	else if( strncmp(pOrgCd, "0SC", 3) == 0 ) /* 삼성카드 */
	{
		nRtn = GetSCTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "007", 3) == 0 ) /* 수협 거래실적 */
	{
		nRtn = GetSuHTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "A07", 3) == 0 ) /* 수협 기기정보 */
	{
		nRtn = GetSuHMacData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "000", 3) == 0 ) /* 금융결제원(KFTC) */
	{
		nRtn = GetKFTCTranData(pDate, szFullFile);
	}
	else if( strncmp(pOrgCd, "0GV", 3) == 0 ) /* 전자상품권  */
	{
		memset((char *)szDestPath, 	(int)0x00, sizeof(szDestPath));
		if ( rd_cnfg_parm((char *)SAM_FILE, (char *)FTP_DEST_GIFT_PATH, szDestPath ) < 0 )
		{
			logger( "main : rd_cnfg_pram FTP_DEST_GIFT_PATH Get Error = [%s]\n", szDestPath );
	   		CleanUp(0);
		}

		memset( szFileName, 0x00, sizeof(szFileName) );
		nRtn = GetGiftCardInfoData(pDate, szSrcPath, szFileName);
	}
	else
	{
		logger( "해당 기관없음 [%s]\n", pOrgCd );
		return -1;
	}

	if( nRtn < 0 )
	{
		logger( "file 생성 실패 [%s]\n", szFileName );
		return -1;
	}
	else
	{
		logger( "file 생성 OK !!! [%s]\n", szFileName );
	}

	memset( szFtpScript, 0x00, sizeof(szFtpScript) );
	memset( szFtpScriptChk, 0x00, sizeof(szFtpScriptChk) );
	sprintf( szFtpScript, "%s/ftpscript", szSrcPath );
	sprintf( szFtpScriptChk, "%s/ftpscriptchk", szSrcPath );

	if(( ftp = fopen( szFtpScript, "w" )) != NULL )

	{
	    fprintf( ftp, "(\n" );
	    fprintf( ftp, "for host in %s\n", szHost );
	    fprintf( ftp, "do\n" );
	    fprintf( ftp, "echo \"\n" );
	    fprintf( ftp, "open %s\n", szHost );
	    fprintf( ftp, "user %s %s\n", szID, szPwd );
	    fprintf( ftp, "ascii\n" );
	    fprintf( ftp, "prompt\n" );
	    fprintf( ftp, "cd %s\n", szDestPath );
	    fprintf( ftp, "delete %s\n", szFileName );
	    fprintf( ftp, "lcd %s\n", szSrcPath );
	    fprintf( ftp, "put %s\n", szFileName );
	    fprintf( ftp, "close\n" );
	    fprintf( ftp, "bye\n" );
	    fprintf( ftp, "\"\n" );
	    fprintf( ftp, "done\n" );
	    fprintf( ftp, ")|ftp -i -n -v > ./ftp_down.log\n");
	    fclose( ftp );

	    if(chmod (szFtpScript, 0755) < 0)
	    {
	    	logger("call to chmod failed\n");
	    	ftpsuccess = 1;
	    }
	    
	    if( system( szFtpScript ) < 0 )
	    {
	    	logger( "ftp 전송 스크립트 실패 HOST[%s] ID[%s] DestPath[%s] SrcPath[%s] FileName[%s]\n",
	    				szHost, szID, szDestPath, szSrcPath, szFileName);
	    	ftpsuccess = 0;
	    }
	    else
	    {
	    	logger( "ftp 전송 스크립트 완료 HOST[%s] ID[%s] DestPath[%s] SrcPath[%s] FileName[%s]\n",
	    				szHost, szID, szDestPath, szSrcPath, szFileName);
	    	ftpsuccess = 0;
	    }
	}
	/* FTP 전송완료 체크. FTP에 접속하여 해당 파일명을 조회한다. */
	if(( ftp = fopen( szFtpScriptChk, "w" )) != NULL )

	{
	    fprintf( ftp, "rslt=`(			\n" );
	    fprintf( ftp, "for host in %s	\n", szHost );
	    fprintf( ftp, "do				\n" );
	    fprintf( ftp, "echo \"			\n" );
	    fprintf( ftp, "open %s			\n", szHost );
	    fprintf( ftp, "user %s %s		\n", szID, szPwd );
	    fprintf( ftp, "cd %s			\n", szDestPath );
	    fprintf( ftp, "ls %s			\n", szFileName );
	    fprintf( ftp, "close			\n" );
	    fprintf( ftp, "bye				\n" );
	    fprintf( ftp, "\"				\n" );
	    fprintf( ftp, "done				\n" );
	    fprintf( ftp, ")|ftp -i -n`		\n");
	    fprintf( ftp, "if [ $rslt = '%s' ] \n" , szFileName );
	    fprintf( ftp, "then				\n");
	    fprintf( ftp, "	exit 0			\n");			/* 조회성공시 0코드 반환 */
	    fprintf( ftp, "else				\n");
	    fprintf( ftp, " exit 1			\n");			/* 조회실패시 1코드 반환 */
	    fprintf( ftp, "fi				\n");
	    fclose( ftp );
		
	    if(chmod (szFtpScriptChk, 0755) < 0)
	    {
	    	logger("call to chmod failed\n");
	    	ftpsuccess = 1;
	    }
	    
	    if( system( szFtpScriptChk ) > 0 )
	    {
	    	logger( "ftp 확인 스크립트 실패 HOST[%s] ID[%s] DestPath[%s] SrcPath[%s] FileName[%s]\n",
	    				szHost, szID, szDestPath, szSrcPath, szFileName);
	    	ftpsuccess = 1;
	    }
	    else
	    {
	    	logger( "ftp 확인 스크립트 완료 HOST[%s] ID[%s] DestPath[%s] SrcPath[%s] FileName[%s]\n",
	    				szHost, szID, szDestPath, szSrcPath, szFileName);
	    	ftpsuccess = 0;
	    	/* 완료 시, T_CM_BATCH_RESULT 에 파일생성 결과를 입력한다.	*/
	    	EXEC SQL INSERT INTO T_CM_BATCH_RESULT
	    				(	JOB_DATE
	    					, PGM_ID
	    					, PGM_RESULT
	    					, INSERT_DATE
	    					, INSERT_UID 
	    				) VALUES (
	    					TO_CHAR(SYSDATE, 'YYYYMMDD')
	    					, 'FILESend_'||:szFileName
	    					, DECODE(:ftpsuccess,0,'OK','ERROR')
	    					, SYSDATE
	    					, 'FILESnd'
	    				);
	    	if ( sqlca.sqlcode == DB_DUP_DATA ) {
	    		EXEC SQL UPDATE T_CM_BATCH_RESULT
						SET	PGM_RESULT = DECODE(:ftpsuccess,0,'OK','ERROR')
							, INSERT_DATE = sysdate
							, INSERT_UID = 'FILESnd'
						WHERE	JOB_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
							AND PGM_ID = 'FILESend_'||:szFileName;
		
				if ( sqlca.sqlcode )
				{ 
					EXEC SQL ROLLBACK WORK;	    		
					logger( "batch 테이블 기록 덮어씌우기 실패 [%300s]\n", SqlErrMsg);
				} 
				else {	
					EXEC SQL COMMIT WORK;
					logger( "batch 테이블 기록 덮어씌우기 성공\n");
				}
	    		
	    	}	
	    	else if ( sqlca.sqlcode ) {
	    		EXEC SQL ROLLBACK WORK;	    		
	    		logger( "batch 테이블 기록 실패 [%300s]\n", SqlErrMsg );
	    	}	
	    	else {
	    		EXEC SQL COMMIT WORK;	
	    		logger( "batch 테이블 기록 성공\n" );
	    	}
	    				
	    }
	}

	/* 20120229 이기섭 요청 BC카드 기기정보전송 일경우 FILE을 2개로 만든다.
	if( strncmp(pOrgCd, "1BC", 3) == 0 )
	{

		memset((char *)szBackFileName, 	(int)0x00, sizeof(szBackFileName));
		sprintf(szBackFileName, "%s_B", szFileName);

		if(( ftp = fopen( szFtpScript, "w" )) != NULL )

		{
		    fprintf( ftp, "(\n" );
		    fprintf( ftp, "for host in %s\n", szHost );
		    fprintf( ftp, "do\n" );
		    fprintf( ftp, "echo \"\n" );
		    fprintf( ftp, "open %s\n", szHost );
		    fprintf( ftp, "user %s %s\n", szID, szPwd );
		    fprintf( ftp, "ascii\n" );
		    fprintf( ftp, "prompt\n" );
		    fprintf( ftp, "cd %s\n", szDestPath );
		    fprintf( ftp, "rename %s\n", szFileName, szBackFileName );
		    fprintf( ftp, "lcd %s\n", szSrcPath );
		    fprintf( ftp, "put %s\n", szFileName );
		    fprintf( ftp, "close\n" );
		    fprintf( ftp, "bye\n" );
		    fprintf( ftp, "\"\n" );
		    fprintf( ftp, "done\n" );
		    fprintf( ftp, ")|ftp -i -n -v > ./ftp_down.log\n");
		    fclose( ftp );

		    if(chmod (szFtpScript, 0755) < 0)
		    {
		    	logger("call to chmod failed\n");
		    	ftpsuccess = 1;
		    }

		    if( system( szFtpScript ) < 0 )
		    {
		    	logger( "ftp BACK_FILE 전송 실패 HOST[%s] ID[%s] DestPath[%s] SrcPath[%s] FileName[%s]\n",
		    				szHost, szID, szDestPath, szSrcPath, szBackFileName);
		    	ftpsuccess = 1;
		    }
		    else
		    {
		    	logger( "ftp BACK_FILE 전송 완료 HOST[%s] ID[%s] DestPath[%s] SrcPath[%s] FileName[%s]\n",
		    				szHost, szID, szDestPath, szSrcPath, szBackFileName);
		    	ftpsuccess = 0;
		    }
		}
	}
	*/

	return ftpsuccess;
}


/* BC 카드 */
int GetBCTranData(char *pTransDate, char *pFileName)
{
EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType[1+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[16+1];
	char	hMacNo[8+1];
	char	hDealAmt[10+1];
	char	hNiceDealAmt[10+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];
	char	hPreDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00, sizeof( hDataType	 ) );
	memset( hDealDate   , 0x00, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00, sizeof( hDealAmt     ) );
	memset( hNiceDealAmt, 0x00, sizeof( hNiceDealAmt ) );
	memset( hDealStatus , 0x00, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00, sizeof( hDealNo      ) );

	memset( hSQLmain	, 0x00, sizeof(hSQLmain));
	memset( hSQLsub		, 0x00, sizeof(hSQLsub));

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCityTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCityTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}


	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetBCTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}
/* 전일자 실적 전송 */
	sprintf(hSQLmain,
			"SELECT '2' AS DATA_TYPE, " \
			"	  	DEAL_DATE, "													\
			"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, "					\
			"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || "							\
			"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, "			\
			"	   	MAC_NO, "														\
			"	   	LPAD(DEAL_AMT/10000, 7, '0') AS DEAL_AMT, "						\
			"	   	LPAD(DEAL_AMT/10000, 7, '0') AS NICE_DEAL_AMT, "				\
			"	   	'0', "															\
			"	   	DEAL_NO "														\
			"FROM   T_FN_NICE_TRAN "												\
			"WHERE  DEAL_DATE = '%s' "												\
			"AND	ORG_CD = '0BC' "												\
			"AND    DEAL_TYPE = '0' "												\
			"AND    DEAL_CLSS = '1300' "											\
			"AND	ADMIS_ORG = 'B' "												\
			"AND    DEAL_STATUS = '0' ",
			hPreDate);

	EXEC SQL PREPARE SBC FROM :hSQLmain;
	EXEC SQL DECLARE CBC CURSOR FOR SBC;
	EXEC SQL OPEN CBC;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetBCTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetBCTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	ncount = 0;
	lnTotalAmt = 0;

	fprintf( pfTran, "1%sNIC000000%*s\n", hPreDate, 52, " " );

	while (1)
	{
		EXEC SQL	FETCH	CBC	INTO 	hDataType,
										hDealDate,
										hDealTime,
										hAccountNo,
										hMacNo,
										hDealAmt,
										hNiceDealAmt,
										hDealStatus,
										hDealNo;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CBC;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
				1, hDataType, 8, hDealDate,	6, hDealTime, 16, hAccountNo, 4, hMacNo,
								7, hDealAmt, 7, hNiceDealAmt, 1, hDealStatus, 12, hDealNo, 8, " ");

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);

		ncount++;
    }
	EXEC SQL CLOSE CBC;

	fprintf( pfTran, "3%08d%013ld%*s\n", ncount, lnTotalAmt, 48, " " );

	fclose(pfTran);

	return 0;
}

/* BC카드 ATM단말기정보 등록 전문 */
int GetBCMacData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hMacNo[16+1];
	char	hOpenDate[8+1];
	char	hZipNo[6+1];
	char	hSetPlace[50+1];
	char	hSetAddr[100+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];
	char	hPreActDate[8+1];
	char	hPrePreActDate[8+1];

	FILE	*pfTran;

	memset( hMacNo      , 0x00, sizeof( hMacNo     ) );
	memset( hOpenDate   , 0x00, sizeof( hOpenDate  ) );
	memset( hZipNo      , 0x00, sizeof( hZipNo     ) );
	memset( hSetPlace   , 0x00, sizeof( hSetPlace  ) );
	memset( hSetAddr    , 0x00, sizeof( hSetAddr   ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPrePreActDate , 0x00	, sizeof( hPrePreActDate   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

/*===>
	휴일에는 전송하지 않는다. 매월 1일에만 전송 2012.02.29 기섭 요청
	/= 전송일이 휴일면 전송일을 전송일이 영업일이면 전 영업일을 return =/
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCityTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCityTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	if( memcmp(pTransDate, hPreActDate, 8 ) == 0  )
	{
		logger(">>> [GetNongHTranData][%s]-[%s] 휴일 전송 하지 않음 \n", pTransDate, hPreActDate);
		return -2;
	}


	/= 전전 영업일을 return =/
	EXEC SQL SELECT pkg_fn_common.sf_getPreActDate(pkg_fn_common.sf_getPreActDate(std_date))
			 INTO	:hPrePreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCityTranData] 전전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCityTranData] 전전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}
<===*/

	if( memcmp( &pTransDate[6], "01", 2 ) != 0 )
	{
		logger( "매월 01일에만 전송 하도록 함.\n" );
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetNongHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}



	ncount = 0;

	fprintf( pfTran, "BHATM-INFO%08s%*s\n", pTransDate, 232, " " );

	sprintf(hSQLmain,
			"SELECT  RPAD(MAC.MAC_NO, 16, ' ') AS MAC_NO,                       	" \
            "        SUBSTR(MAC.MAC_NM, 1, 50),                              		" \
            "        MAC.OPEN_DATE,                                            		" \
            "        SITE.ZIP_NO,                                              		" \
            "        SUBSTR(SITE.SET_ADDR, 1, 100)                              	" \
            "FROM    T_CM_MAC        MAC,                                       	" \
            "        T_CM_SITE       SITE,                                      	" \
            "        T_CT_NICE_MAC   NMAC                                       	" \
            "WHERE   MAC.ORG_CD = '096'                                          	" \
            "AND     MAC.JIJUM_CD = '9600'                                      	" \
            "AND	 MAC.OPEN_DATE <= :hTransDate									" \
            "AND	(MAC.CLOSE_DATE IS NULL OR MAC.CLOSE_DATE >= :hTransDate)		" \
            "AND     MAC.ORG_CD = SITE.ORG_CD                                   	" \
            "AND     MAC.JIJUM_CD = SITE.JIJUM_CD                               	" \
            "AND     MAC.SITE_CD = SITE.SITE_CD                                 	" \
			"AND	 MAC.MAC_NO < 'A000'										    " \
            "AND     MAC.MAC_NO = NMAC.MAC_NO                                   	" );

    EXEC SQL PREPARE SBC2 FROM :hSQLmain;
	EXEC SQL DECLARE CBC2 CURSOR FOR SBC2;

	EXEC SQL OPEN CBC2 USING :pTransDate,
							 :pTransDate;


	if( sqlca.sqlcode )
	{
		logger( ">>> [GetNongHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetNongHTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	while (1)
	{
		EXEC SQL	FETCH	CBC2	INTO 	hMacNo,
											hSetPlace,
											hOpenDate,
											hZipNo,
											hSetAddr;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CBC2;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "BD03102%.*s%.*s%.*s080022 8252%.*s%.*s%*s\n",
				16, hMacNo, 50, hSetPlace, 8, hOpenDate,
				6, hZipNo, 100, hSetAddr, 52, " ");

		ncount++;
    }
	EXEC SQL CLOSE CBC2;

	fprintf( pfTran, "BT%08ld%*s\n", ncount, 240, " " );

	fclose(pfTran);
	return 0;
}

/* 국민카드 */
int GetCNTranData(char *pTransDate, char *pFileName)
{
EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType[1+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[16+1];
	char	hMacNo[8+1];
	char	hDealAmt[10+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];
	char	hPreDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[10240];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00, sizeof( hDataType	 ) );
	memset( hDealDate   , 0x00, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00, sizeof( hDealNo      ) );
	memset( hPreDate    , 0x00, sizeof( hPreDate     ) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCNTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	sprintf(hSQLmain,
			"SELECT '2' AS DATA_TYPE, "										\
			"	  	DEAL_DATE, "											\
			"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, "			\
			"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || "					\
			"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, "	\
			"	   	MAC_NO, "												\
			"	   	LPAD(DEAL_AMT, 10, '0'), "								\
			"	   	DEAL_STATUS, "											\
			"	   	DEAL_NO "												\
			"FROM   T_FN_NICE_TRAN "										\
			"WHERE  DEAL_DATE = '%s' "										\
			"AND	ORG_CD = '0CN' "										\
			"AND    DEAL_TYPE = '0' "										\
			"AND    DEAL_CLSS = '1300' "									\
			"AND	ADMIS_ORG = 'B' "										\
			"AND    DEAL_STATUS = '0' ",
			hPreDate);

	EXEC SQL PREPARE S1 FROM :hSQLmain;
	EXEC SQL DECLARE C1 CURSOR FOR S1;
	EXEC SQL OPEN C1;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetCNTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetCNTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	ncount = 0;
	lnTotalAmt = 0;

	fprintf( pfTran, "1%sKMC%*s\n", hPreDate, 58, " " );

	while (1)
	{
		EXEC SQL	FETCH	C1	INTO 	hDataType,
										hDealDate,
										hDealTime,
										hAccountNo,
										hMacNo,
										hDealAmt,
										hDealStatus,
										hDealNo;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE C1;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
				1, hDataType, 8, hDealDate,	6, hDealTime, 16, hAccountNo, 8, hMacNo,
										10, hDealAmt, 1, hDealStatus, 12, hDealNo, 8, " ");

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);

		ncount++;
    }
	EXEC SQL CLOSE C1;

	fprintf( pfTran, "3%08d%013ld%*s\n", ncount, lnTotalAmt, 48, " " );

	fclose(pfTran);

	return 0;
}

int GetCNMacData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hSetYn[2+1];
	char	hMacNo[8+1];
	char	hSetDate[8+1];
	char	hOpenDate[8+1];
	char	hUpdateDate[8+1];
	char	hCloseDate[8+1];
	char	hZipNo[6+1];
	char	hSetPlace[60+1];
	char	hSetAddr[30+1];
	char	hInterPhone[20+1];
	char	hPicYn[1+1];
	char	hCDType[2+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];
	char	hPreActDate[8+1];
	char	hPrePreActDate[8+1];

	FILE	*pfTran;

	memset( hSetYn		, 0x00, sizeof( hSetYn     ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo     ) );
	memset( hSetDate    , 0x00, sizeof( hSetDate   ) );
	memset( hOpenDate   , 0x00, sizeof( hOpenDate  ) );
	memset( hUpdateDate , 0x00, sizeof( hUpdateDate) );
	memset( hCloseDate  , 0x00, sizeof( hCloseDate ) );
	memset( hZipNo      , 0x00, sizeof( hZipNo     ) );
	memset( hSetPlace   , 0x00, sizeof( hSetPlace  ) );
	memset( hSetAddr    , 0x00, sizeof( hSetAddr   ) );
	memset( hInterPhone , 0x00, sizeof( hInterPhone) );
	memset( hPicYn      , 0x00, sizeof( hPicYn     ) );
	memset( hCDType     , 0x00, sizeof( hCDType    ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPrePreActDate , 0x00	, sizeof( hPrePreActDate   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	/* 전송일이 휴일면 전송일을 전송일이 영업일이면 전 영업일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCityTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCityTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	if( memcmp(pTransDate, hPreActDate, 8 ) == 0  )
	{
		logger(">>> [GetNongHTranData][%s]-[%s] 휴일 전송 하지 않음 \n", pTransDate, hPreActDate);
		return -2;
	}

	/* 전전 영업일을 return */
	EXEC SQL SELECT pkg_fn_common.sf_getPreActDate(pkg_fn_common.sf_getPreActDate(std_date))
			 INTO	:hPrePreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCityTranData] 전전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCityTranData] 전전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetNongHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	ncount = 0;

	fprintf( pfTran, "H%08s%*s\n", pTransDate, 191, " " );

	/* 변경분만 전송 */
	sprintf(hSQLmain,
			"SELECT  CASE WHEN NVL(MAC.OPEN_DATE, '0') >= :hPreActDate THEN '01'	" \
            "              WHEN MAC.CLOSE_DATE IS NOT NULL AND                  	" \
            "                    MAC.CLOSE_DATE < :hPreActDate THEN '03'         	" \
            "              ELSE '02'                                            	" \
            "        END AS SET_YN,                                            		" \
            "        RPAD(MAC.MAC_NO, 8, ' ') AS MAC_NO,                       		" \
            "        MAC.SET_DATE,                                             		" \
            "        MAC.OPEN_DATE,                                            		" \
            "        TO_CHAR(MAC.UPDATE_DATE, 'YYYYMMDD'),                     		" \
            "        RPAD(MAC.CLOSE_DATE, 8, '0'),                             		" \
            "        SITE.ZIP_NO,                                              		" \
            "        SUBSTR(SITE.SET_ADDR, 1, 28),                              	" \
            "        SUBSTR(SITE.SET_ADDR, 1, 13),                              	" \
            "		 SITE.INTERPHONE_NO,											" \
            "        DECODE(NVL(SITE.PIC_YN, 0), 0, 'N', 'Y') AS PIC_YN,         	" \
            "		 DECODE(MAC.MAC_MODEL, '1300', '01', 							" \
            "            DECODE(MAC.MAC_MODEL, '1400', '01', '02' ) ) AS MAC_MODEL	" \
            "FROM    T_CM_MAC        MAC,                                       	" \
            "        T_CM_SITE       SITE,                                      	" \
            "        T_CT_NICE_MAC   NMAC                                       	" \
            "WHERE   MAC.ORG_CD = '096'                                          	" \
            "AND     MAC.JIJUM_CD = '9600'                                      	" \
            "AND     MAC.ORG_CD = SITE.ORG_CD                                   	" \
            "AND     MAC.JIJUM_CD = SITE.JIJUM_CD                               	" \
            "AND     MAC.SITE_CD = SITE.SITE_CD                                 	" \
            "AND     MAC.MAC_NO = NMAC.MAC_NO                                   	" \
            "AND     TO_CHAR(MAC.UPDATE_DATE, 'YYYYMMDD') > :hPrePreActDate 		" );

    EXEC SQL PREPARE SCN2 FROM :hSQLmain;
	EXEC SQL DECLARE CCN2 CURSOR FOR SCN2;

	EXEC SQL OPEN CCN2 USING :hPreActDate,
							 :hPreActDate,
							 :hPrePreActDate;


	/* 처음 전체 전송 시 사용
	sprintf(hSQLmain,
			"SELECT  '01' AS SET_YN,                                            	" \
            "        RPAD(MAC.MAC_NO, 8, ' ') AS MAC_NO,                       		" \
            "        MAC.SET_DATE,                                             		" \
            "        MAC.OPEN_DATE,                                            		" \
            "        TO_CHAR(MAC.UPDATE_DATE, 'YYYYMMDD'),                     		" \
            "        RPAD(MAC.CLOSE_DATE, 8, '0'),                             		" \
            "        SITE.ZIP_NO,                                              		" \
            "        SUBSTR(SITE.SET_ADDR, 1, 28),                              	" \
            "        SUBSTR(SITE.SITE_NM, 1, 13),                              		" \
            "		 SITE.INTERPHONE_NO,											" \
            "        DECODE(NVL(SITE.PIC_YN, 0), 0, 'N', 'Y') AS PIC_YN,         	" \
            "		 DECODE(MAC.MAC_MODEL, '1300', '01', 							" \
            "            DECODE(MAC.MAC_MODEL, '1400', '01', '02' ) ) AS MAC_MODEL	" \
            "FROM    T_CM_MAC        MAC,                                       	" \
            "        T_CM_SITE       SITE,                                      	" \
            "        T_CT_NICE_MAC   NMAC                                       	" \
            "WHERE   MAC.ORG_CD = '096'                                          	" \
            "AND     MAC.JIJUM_CD = '9600'                                      	" \
            "AND     MAC.ORG_CD = SITE.ORG_CD                                   	" \
            "AND     MAC.JIJUM_CD = SITE.JIJUM_CD                               	" \
            "AND     MAC.SITE_CD = SITE.SITE_CD                                 	" \
            "AND     MAC.MAC_NO = NMAC.MAC_NO                                   	" \
            "AND     MAC.OPEN_DATE <= :hPreActDate							 		" \
            "AND  (  MAC.CLOSE_DATE IS NULL OR MAC.CLOSE_DATE >= :hPreActDate )		" );


	EXEC SQL PREPARE SCN2 FROM :hSQLmain;
	EXEC SQL DECLARE CCN2 CURSOR FOR SCN2;

	EXEC SQL OPEN CCN2 USING :hPreActDate,
							 :hPreActDate;
	*/

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetNongHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetNongHTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}


	while (1)
	{
		EXEC SQL	FETCH	CCN2	INTO 	hSetYn,
											hMacNo,
											hSetDate,
											hOpenDate,
											hUpdateDate,
											hCloseDate,
											hZipNo,
											hSetPlace,
											hSetAddr,
											hInterPhone,
											hPicYn,
											hCDType;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CCN2;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "D%.*s96%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
				2, hSetYn, 8, hMacNo, 8, hSetDate, 8, hOpenDate,
				8, hUpdateDate, 8, hCloseDate, 6, hZipNo,
				60, hSetPlace, 30, hSetAddr, 20, hInterPhone,
				1, hPicYn, 2, hCDType, 36, " ");

		ncount++;
    }
	EXEC SQL CLOSE CCN2;

	fprintf( pfTran, "T%.8s%010ld%*s\n", pTransDate, ncount, 181, " " );

	fclose(pfTran);
	return 0;
}

/* 신한은행 */
int GetSHTranData(char *pTransDate, char *pFileName, char * pDealType)
{
EXEC SQL BEGIN DECLARE SECTION;
	char	hDealType[1+1];
	char	hDataType[2+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hSeqNo[7+1];
	char	hAccountNo[16+1];
	char	hMacNo[10+1];
	char	hDealAmt[12+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];
	char	hPreDate[8+1];
	char	hOrgCd[7+1];
	char	hMsgType[4+1];
	char	hNotendInOrgCd[3+1];		/* 입금미완료 은행코드 		*/
	char	hNotendInAccountNo[17+1];	/* 입금미완료 계좌정보		*/
	char	hNotendOutFlag	[1+1];		/* 출금미완료 Flag			*/
	char	hNotendOutDealdate[8+1];	/* 출금미완료 거래일자		*/

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
	char	hSQLsub2[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount = 1;
	char	szContent[10240];

	unsigned long	lnTotalAmt = 0;

	FILE	*pfTran;

	char	szFileName[512];

	memset( hDataType	, 0x00, sizeof( hDataType	 ) );
	memset( hDealType	, 0x00, sizeof( hDealType	 ) );
	memset( hDealDate   , 0x00, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00, sizeof( hDealNo      ) );
	memset( hPreDate    , 0x00, sizeof( hPreDate     ) );
	memset( hSeqNo    , 0x00, sizeof( hSeqNo     ) );
	memset( hOrgCd    , 0x00, sizeof( hOrgCd     ) );
	memset( hMsgType    , 0x00, sizeof( hMsgType     ) );
	memset( hNotendInOrgCd, 0x00, sizeof( hNotendInOrgCd ) );
	memset( hNotendInAccountNo, 0x00, sizeof( hNotendInAccountNo ) );
	memset( hNotendOutFlag, 0x00, sizeof( hNotendOutFlag ) );
	memset( hNotendOutDealdate, 0x00, sizeof( hNotendOutDealdate ) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));
	memset(hSQLsub2,		0x00, sizeof(hSQLsub2));

	sprintf( hNotendOutFlag, "%s", "1" );			/* 출금미완료 FLAG		*/

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCNTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	if( strncmp( pDealType, "0", 1 ) == 0 )/* 지급 */
	{
		strcpy( hOrgCd, "NICEBNK" );
		sprintf(hSQLsub,
			"AND	T.DEAL_TYPE = '0'						 	" \
			"AND	T.ORG_CD IN ('088', '026', '021', '0') 	" \
			"AND	T.NET_ORG_CD in ('088', '099') 			" );
		sprintf(hSQLsub2,	"AND	T.DEAL_TYPE = '0'	");
	}
	else
	{
		strcpy( hOrgCd, "P001226" );
		sprintf(hSQLsub,
			"AND	T.DEAL_TYPE in ('1', '4')					" \
			"AND	T.NET_ORG_CD = '088'			 			" );
		sprintf(hSQLsub2,	"AND	T.DEAL_TYPE in ('1', '4')	");
	}

	/* 출금일경우 거래고유번호 앞 두자리를 '00'으로
		이체일 경우 거래고유번호 앞 6자리를 '000000'으로 20100811 이재원과장 요청 */
	/* 이체일 경우 입금거래 포함하도록 수정 20101111 김재환요청
	   => 입금일경우 st_org_cd(org_cd) = '0'으로 저장됨 */
	/* 입금거래 시 org_cd = '0' 이던것을 각 입금 기관코드를 표시하도록 TRAN 데이터가 바뀜 (2011.11.22 이재원과장)
	   따라서 출금 일 경우 개별망(088)과 공동망(099) 을 모두 사용하므로 net_org_cd, org_cd를 모두
	   참조하도록 (=> 공동망을 탈경우 전 기관의 거래가 들어 가므로 org_cd를 통해 신한은행 거래만 거름)
	   이체와 입금 거래는 개별망을 타므로 NET_ORG_CD 만으로 신한은행 거래인지 구분 가능 */

/*===> 2013.04.24 미완료 거래 송신은 지사 공지 완료 이후 적용 해야 함 임시 주석 처리
	sprintf(hSQLmain,
			"SELECT   '22' AS DATA_TYPE,                                            	"\
			"	  	N.NOTEND_DATE, 											       		"\
			"	   	T.DEAL_HOUR||T.DEAL_MI||T.DEAL_SEC AS DEAL_TIME,		       		"\
			"	   	T.MAC_NO, 												       		"\
			"	   	LPAD(T.DEAL_AMT, 12, '0'), 								       		"\
			"	   	T.DEAL_STATUS, 											       		"\
			"		DECODE( '%s', '0', '00'||SUBSTR(T.DEAL_NO, 3, 10), 		        	"\
			"						   '000000'||SUBSTR(T.DEAL_NO, 7, 6)), 	       		"\
			"		T.DEAL_TYPE, 											       		"\
			"	 	DECODE(N.NOTEND_DATE,'','',DECODE(T.DEAL_TYPE,'1',N.BANK_CD)), 		"\
			"		DECODE(N.NOTEND_DATE,'','',DECODE(T.DEAL_TYPE,'1',N.ACCOUNT_NO)), 	"\
			"	 	DECODE(N.NOTEND_DATE,'','',DECODE(T.DEAL_TYPE,'0','1')), 		   	"\
			"	 	DECODE(N.NOTEND_DATE,'','',DECODE(T.DEAL_TYPE,'0',T.DEAL_DATE))    	"\
			"FROM T_FN_NOTEND N, T_FN_ATMS_REPORT R , T_FN_NICE_TRAN T		       		"\
			"WHERE T.DEAL_DATE = N.DEAL_DATE(+)                                    		"\
			"  AND T.DEAL_NO   = N.UNIQUE_NO(+)                                    		"\
			"  AND T.DEAL_DATE = '%s'	                                        		"\
			"  AND N.NOTEND_DATE = R.NOTEND_DATE(+) 									"\
			"	AND N.ORG_CD = R.ORG_CD(+)        								   		"\
			"	AND N.JIJUM_CD = R.JIJUM_CD(+)    								   		"\
			"	AND N.MAC_NO = R.MAC_NO(+)        								   		"\
			"	AND N.TRAN_NO = R.TRADE_NO(+)                                      		"\
			"%s																			"\
			"	AND T.DEAL_STATUS = '0'													"\
			"UNION ALL                                                             		"\
			"SELECT  '22' AS DATA_TYPE,                                            		"\
			"	  	N.NOTEND_DATE, 											       		"\
			"	   	T.DEAL_HOUR||T.DEAL_MI||T.DEAL_SEC AS DEAL_TIME, 		       		"\
			"	   	T.MAC_NO, 												       		"\
			"	   	LPAD(T.DEAL_AMT, 12, '0'), 								       		"\
			"	   	T.DEAL_STATUS, 											       		"\
			"		DECODE( '%s', '0', '00'||SUBSTR(T.DEAL_NO, 3, 10), 		       		"\
			"						   '000000'||SUBSTR(T.DEAL_NO, 7, 6)), 	       		"\
			"		T.DEAL_TYPE, 											       		"\
			"	 	DECODE(T.DEAL_TYPE,'1',N.BANK_CD), 						       		"\
			"		DECODE(T.DEAL_TYPE,'1',N.ACCOUNT_NO), 					       		"\
			"	 	DECODE(T.DEAL_TYPE,'0','1'), 							       		"\
			"	 	DECODE(T.DEAL_TYPE,'0',T.DEAL_DATE)                            		"\
			"FROM T_FN_NOTEND N, T_FN_ATMS_REPORT R , T_FN_NICE_TRAN T		       		"\
			"WHERE N.NOTEND_DATE = R.NOTEND_DATE 								   		"\
			"	AND N.ORG_CD = R.ORG_CD        								       		"\
			"	AND N.JIJUM_CD = R.JIJUM_CD    								       		"\
			"	AND N.MAC_NO = R.MAC_NO        								       		"\
			"	AND N.TRAN_NO = R.TRADE_NO     								       		"\
			"	AND T.DEAL_YEAR = SUBSTR(N.DEAL_DATE, 1, 4)					       		"\
			"	AND T.DEAL_NO = N.UNIQUE_NO   								       		"\
			"	AND N.NOTEND_DATE = '%s'										   		"\
			"	AND N.ORG_CD = '096'          								       		"\
			"	AND N.BANK_CD = '088'         								       		"\
			"	AND N.AUTO_YN = '1'                                                		"\
			"  AND N.DEAL_DATE < '%s'									           		"\
			"%s																			",
			pDealType, hPreDate, hSQLsub, pDealType, hPreDate, hPreDate, hSQLsub2);
<===*/


	sprintf(hSQLmain,
			"SELECT   '22' AS DATA_TYPE,                                            	"\
			"	  	T.DEAL_DATE, 											       		"\
			"	   	T.DEAL_HOUR||T.DEAL_MI||T.DEAL_SEC AS DEAL_TIME,		       		"\
			"	   	T.MAC_NO, 												       		"\
			"	   	LPAD(T.DEAL_AMT, 12, '0'), 								       		"\
			"	   	T.DEAL_STATUS, 											       		"\
			"		DECODE( '%s', '0', '00'||SUBSTR(T.DEAL_NO, 3, 10), 		        	"\
			"						   '000000'||SUBSTR(T.DEAL_NO, 7, 6)), 	       		"\
			"		T.DEAL_TYPE, 											       		"\
			"	 	' ', 																"\
			"		' ', 																"\
			"	 	' ', 		   														"\
			"	 	' '    																"\
			"FROM T_FN_NICE_TRAN T		       											"\
			"WHERE T.DEAL_DATE = '%s'	                                        		"\
			"%s																			"\
			"	AND T.DEAL_STATUS = '0'													",
			pDealType, hPreDate, hSQLsub);
logger("hPreDate[%s], pDealType[%.*s]\n", hPreDate, 1, pDealType);

	EXEC SQL PREPARE S88 FROM :hSQLmain;
	EXEC SQL DECLARE C88 CURSOR FOR S88;
	EXEC SQL OPEN C88;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetSHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetSHTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}
	/* 요청에 의해 필러 1바이트 늘림 */
	fprintf( pfTran, "JH0001110000000%.*s%s%*s\n", 7, hOrgCd, hPreDate, 70, " " );

	while (1)
	{
		EXEC SQL	FETCH	C88	INTO 	hDataType,
										hDealDate,
										hDealTime,
										hMacNo,
										hDealAmt,
										hDealStatus,
										hDealNo,
										hDealType,
										hNotendInOrgCd,
										hNotendInAccountNo,
										hNotendOutFlag,
										hNotendOutDealdate;

		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE C88;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);


		memset( hMsgType, 0x00, sizeof( hMsgType ) );

		if( strncmp( hDealType, "0", 1 ) == 0 )/* 지급 */
		{
			strcpy( hMsgType, "0770" );
		}
		else if( strncmp( hDealType, "4", 1 ) == 0 )/* 이체 */
		{
			strcpy( hMsgType, "0780" );
		}
		else if( strncmp( hDealType, "1", 1 ) == 0 )/* 입금 */
		{
			strcpy( hMsgType, "0760" );
		}

		memset( szContent, 0x00, sizeof(szContent) );

		/* 요청에 의해 필러 1바이트 늘림 */
		fprintf( pfTran, "JH0001%.*s%07d%.*s%.*s%.*s%.*s%.*s0%.*s%.*s%.*s%.*s%.*s%*s\n",
				2, hDataType, ncount, 4, hMsgType, 12, hDealNo,	6, hDealTime, 12, hDealAmt,
				1, hDealStatus, 10, hMacNo, 3, hNotendInOrgCd, 17, hNotendInAccountNo,
				1, hNotendOutFlag, 8, hNotendOutDealdate, 10, " ");

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);

		ncount++;

		memset( hDealType, 0x00, sizeof( hDealType ) );


    }
	EXEC SQL CLOSE C88;

	/*************************************************************************
		신한은행 미완료처리
														2012.12.06.최락경
		- 기존 데이터파일의 필러를 추가하고
		  해당 부분에 미완료 관련 데이터를 삽입
	*************************************************************************/
	/* 폐기
	sprintf(hSQLmain,
			"SELECT '22' AS DATA_TYPE, 										"\
			"	  	LPAD(rownum, 7, '0') as seq_no, 						"\
			"	  	N.NOTEND_DATE, 											"\
			"	   	T.DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, 			"\
			"	   	T.MAC_NO, 												"\
			"	   	LPAD(T.DEAL_AMT, 12, '0'), 								"\
			"	   	T.DEAL_STATUS, 											"\
			"		DECODE( '%s', '0', '00'||SUBSTR(T.DEAL_NO, 3, 10), 		"\
			"						   '000000'||SUBSTR(T.DEAL_NO, 7, 6)), 	"\
			"		T.DEAL_TYPE, 											"\
			"	 	DECODE(T.DEAL_TYPE,'1',N.BANK_CD), 						"\
			"		DECODE(T.DEAL_TYPE,'1',N.ACCOUNT_NO), 					"\
			"	 	DECODE(T.DEAL_TYPE,'0','1'), 							"\
			"	 	DECODE(T.DEAL_TYPE,'0',T.DEAL_DATE), 					"\
			"FROM T_FN_NOTEND N, T_FN_ATMS_REPORT R , T_FN_NICE_TRAN T		"\
			"WHERE                          								"\
			"	 N.NOTEND_DATE = R.NOTEND_DATE 								"\
			"	AND N.ORG_CD = R.ORG_CD        								"\
			"	AND N.JIJUM_CD = R.JIJUM_CD    								"\
			"	AND N.MAC_NO = R.MAC_NO        								"\
			"	AND N.TRAN_NO = R.TRADE_NO     								"\
			"	AND N.DEAL_DATE = T.DEAL_DATE  								"\
			"	AND N.UNIQUE_NO = T.DEAL_NO    								"\
			"	AND N.NOTEND_DATE = '%s'									"\
			"	AND N.ORG_CD = '096'          								"\
			"	AND N.BANK_CD = '088'         								"\
			"	AND N.AUTO_YN = '1'           								",
			pDealType, hPreDate);
logger("hPreDate[%s], pDealType[%.*s]\n", hPreDate, 1, pDealType);

	EXEC SQL PREPARE S88 FROM :hSQLmain;
	EXEC SQL DECLARE C88 CURSOR FOR S88;
	EXEC SQL OPEN C88;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetSHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetSHTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	while (1)
	{
		EXEC SQL	FETCH	C88	INTO 	hDataType,
										hSeqNo,
										hDealDate,
										hDealTime,
										hMacNo,
										hDealAmt,
										hDealStatus,
										hDealNo,
										hDealType,
										hNotendInOrgCd,
										hNotendInAccountNo,
										hNotendOutFlag,
										hNotendOutDealdate;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);

		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE C88;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);


		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);


		memset( hMsgType, 0x00, sizeof( hMsgType ) );

		if( strncmp( hDealType, "0", 1 ) == 0 )
		{
			strcpy( hMsgType, "0770" );
		}
		else if( strncmp( hDealType, "4", 1 ) == 0 )
		{
			strcpy( hMsgType, "0780" );
		}
		else if( strncmp( hDealType, "1", 1 ) == 0 )/
		{
			strcpy( hMsgType, "0760" );
		}

		memset( szContent, 0x00, sizeof(szContent) );
		fprintf( pfTran, "JH0001%.*s%.*s%.*s%.*s%.*s%.*s%.*s0%.*s%*s\n",
				2, hDataType, 7, hSeqNo, 4, hMsgType, 12, hDealNo,	6, hDealTime, 12, hDealAmt,
				1, hDealStatus, 10, hMacNo, , 3, hNotendInOrgCd, 17, hNotendInAccountNo,
				1, hNotendOutFlag, 8, hNotendOutDealdate, 9, " ");

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);
		ncount++;
		memset( hDealType, 0x00, sizeof( hDealType ) );

    }
	EXEC SQL CLOSE C88;
*/
/* 요청에 의해 필러 1바이트 늘림 */
	fprintf( pfTran, "JH000133999999900000000000000000000%08d%012lu%08d%012lu%*s\n",
								ncount-1, lnTotalAmt, ncount-1, lnTotalAmt, 25, " " );

	fclose(pfTran);

	return 0;
}

/* 삼성해외카드 */
int GetSCTranData(char *pTransDate, char *pFileName)
{
EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType[1+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[19+1];
	char	hMacNo[8+1];
	char	hDealAmt[18+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];
	char	hPreDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[10240];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00, sizeof( hDataType	 ) );
	memset( hDealDate   , 0x00, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00, sizeof( hDealNo      ) );
	memset( hPreDate    , 0x00, sizeof( hPreDate     ) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCNTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	sprintf(hSQLmain,
			"SELECT DEAL_DATE, "											\
			"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, "			\
			"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || "					\
			"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, "	\
			"	   	LPAD(DEAL_AMT, 18, '0'), "								\
			"	   	DEAL_NO "												\
			"FROM   T_FN_NICE_TRAN "										\
			"WHERE  DEAL_DATE = '%s' "										\
			"AND	ORG_CD = '0SC' "										\
			"AND    DEAL_TYPE = '0' "										\
			"AND    DEAL_STATUS = '0' ",
			hPreDate);

	EXEC SQL PREPARE SSC FROM :hSQLmain;
	EXEC SQL DECLARE CSC CURSOR FOR SSC;
	EXEC SQL OPEN CSC;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetCNTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetCNTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	ncount = 0;
	lnTotalAmt = 0;

	fprintf( pfTran, "HEADER  96        %s%*s\n", hPreDate, 4, " " );

	while (1)
	{
		EXEC SQL	FETCH	CSC	INTO 	hDealDate,
										hDealTime,
										hAccountNo,
										hDealAmt,
										hDealNo;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CSC;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s\n",
				8, hDealDate,	6, hDealTime, 19, hAccountNo,
										18, hDealAmt, 12, hDealNo);

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);

		ncount++;
    }
	EXEC SQL CLOSE CSC;

	fprintf( pfTran, "TRAILER 96        %012d\n", ncount);

	fclose(pfTran);

	return 0;
}


/* 하나은행 개별망*/
int GetHNetTranData(char *pTransDate, char *pFileName)
{
EXEC SQL BEGIN DECLARE SECTION;
	char	hWorkType[6+1];
	char	hDataType[2+1];
	char	hDealType[6+1];
	char	hDealNo[12+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[16+1];
	char	hMacNo[8+1];
	char	hDealAmt[12+1];
	char	hDealStatus[1+1];
	char	hPreDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[10240];
	char	szCnt[10];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00, sizeof( hDataType	 ) );
	memset( hWorkType	, 0x00, sizeof( hWorkType	 ) );
	memset( hDealDate   , 0x00, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00, sizeof( hDealNo      ) );
	memset( szCnt     	, 0x00, sizeof( szCnt      	 ) );
	memset( hPreDate    , 0x00, sizeof( hPreDate     ) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetHNetTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	sprintf(hSQLmain,
			"SELECT 'HB0001' as WORK_TYPE,														" \
			"	   '22' AS DATA_TYPE,                                                           " \
			"		CASE WHEN DEAL_TYPE||DEAL_CLSS = '01000' /* 예금인출 */						" \
			"			 	  THEN                                                              " \
			"				  	   CASE WHEN DEAL_TIME_TYPE = '1' /* 예금인출-시간내 */         " \
			"					   			 THEN '012200'                                      " \
			"							WHEN DEAL_TIME_TYPE = '2' /* 예금인출-시간외 */         " \
			"								 THEN '012300'                                      " \
			"						ELSE DEAL_TYPE||DEAL_CLSS||TRACK_NO 						" \
			"						END                                                         " \
			"			 /* 계좌이체 */                                                         " \
			"			WHEN DEAL_TYPE||DEAL_CLSS = '40000'                                     " \
			"				 THEN                                                               " \
			"				 	 /* 계좌이체 - 자행 */                                          " \
			"					 CASE WHEN TRANS_ORG_CD = '0081'                                " \
			"					  	   		THEN                                                " \
			"							   	    /* 계좌이체 - 자행이체 - 시간내 */              " \
			"									CASE WHEN DEAL_TIME_TYPE = '1'                  " \
			"											 THEN '400000'                          " \
			"									 	 /* 계좌이체 - 자행이체 - 시간외 */         " \
			"										 WHEN DEAL_TIME_TYPE = '2'                  " \
			"											 THEN '400001'                          " \
			"										 ELSE DEAL_TYPE||DEAL_CLSS||TRACK_NO		" \
			"									END                                             " \
			"							ELSE                                                    " \
			"								    /* 계좌이체 - 타행이체 - 시간내 */              " \
			"									CASE WHEN DEAL_TIME_TYPE = '1'                  " \
			"											 THEN '400020'                          " \
			"									 	 /* 계좌이체  - 타행이체 - 시간외 */        " \
			"										 WHEN DEAL_TIME_TYPE = '2'                  " \
			"											 THEN '400021'                          " \
			"										 ELSE DEAL_TYPE||DEAL_CLSS||TRACK_NO		" \
			"									END                                             " \
			"						END                                                         " \
			"			ELSE DEAL_TYPE||DEAL_CLSS||TRACK_NO                                     " \
			"		END AS DEAL_TYPE,                                                          	" \
			"		'9A' || MAC_NO || 'N' || LPAD( ATM_DEAL_NO, 5, '0' ) AS DEAL_NO,            " \
			"		DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME,                                  " \
			"		LPAD( DEAL_AMT, 12, '0' ) AS DEAL_AMT,                                      " \
			"		DECODE(DEAL_STATUS, '0', '0', '1', '1', '2', '3', '3', '2') AS DEAL_STATUS  " \
			"FROM	T_FN_NICE_TRAN                                                              " \
			"WHERE	DEAL_DATE = '%s'                                                      		" \
			"AND	NET_ORG_CD = '081'                                                       	" \
			"AND	ADMIS_ORG = 'B' 															" \
			"AND   (DEAL_TYPE = '0' OR DEAL_TYPE = '4' )										",
			hPreDate);

	EXEC SQL PREPARE S8N FROM :hSQLmain;
	EXEC SQL DECLARE C8N CURSOR FOR S8N;
	EXEC SQL OPEN C8N;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetHNetTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetHNetTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	ncount = 0;
	lnTotalAmt = 0;

	fprintf( pfTran, "HB00011100000009A0000000%08s%*s\n", hPreDate, 28, " " );

	while (1)
	{
		EXEC SQL	FETCH	C8N	INTO 	hWorkType,
										hDataType,
										hDealType,
										hDealNo,
										hDealTime,
										hDealAmt,
										hDealStatus;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE C8N;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "%.*s%.*s%07ld%.*s%.*s%.*s%.*s%.*s%*s\n",
								6,	hWorkType,
								2,	hDataType,
								ncount+1,
								6,	hDealType,
								12,	hDealNo,
								6,	hDealTime,
								12,	hDealAmt,
								1,	hDealStatus,
								8,	" ");

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);

		ncount++;
    }
	EXEC SQL CLOSE C8N;

	fprintf( pfTran, "HB00013399999999A%07ld%*s\n", ncount, 36, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+2, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);

	return 0;
}


/* 하나은행 신규 20090302 */
int GetHNetNewTranData(char *pTransDate, char *pFileName)
{
EXEC SQL BEGIN DECLARE SECTION;
	char	hWorkType[6+1];
	char	hDataType[2+1];
	char	hDealType[6+1];
	char	hDealNo[13+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[16+1];
	char	hMacNo[8+1];
	char	hDealAmt[12+1];
	char	hDealStatus[1+1];
	char	hPreDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[10240];
	char	szCnt[10];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00, sizeof( hDataType	 ) );
	memset( hWorkType	, 0x00, sizeof( hWorkType	 ) );
	memset( hDealDate   , 0x00, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00, sizeof( hDealNo      ) );
	memset( szCnt     	, 0x00, sizeof( szCnt      	 ) );
	memset( hPreDate    , 0x00, sizeof( hPreDate     ) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetHNetTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	sprintf(hSQLmain,
			"SELECT 'HB0001' as WORK_TYPE,																" \
			"	   '22' AS DATA_TYPE,                                                           		" \
			"		CASE WHEN DEAL_TYPE||DEAL_CLSS = '01000' /* 예금인출 */								" \
			"			 	  THEN                                                              		" \
			"				  	   CASE WHEN DEAL_TIME_TYPE = '1' /* 예금인출-시간내 */         		" \
			"					   			 THEN '012200'                                      		" \
			"							WHEN DEAL_TIME_TYPE = '2' /* 예금인출-시간외 */         		" \
			"								 THEN '012300'                                      		" \
			"						ELSE DEAL_TYPE||DEAL_CLSS||TRACK_NO 								" \
			"						END                                                         		" \
			"			 /* 계좌이체 */                                                         		" \
			"			WHEN DEAL_TYPE||DEAL_CLSS = '40000'                                     		" \
			"				 THEN                                                               		" \
			"				 	 /* 계좌이체 - 자행 */                                          		" \
			"					 CASE WHEN TRANS_ORG_CD = '0081'                                		" \
			"					  	   		THEN                                                		" \
			"							   	    /* 계좌이체 - 자행이체 - 시간내 */              		" \
			"									CASE WHEN DEAL_TIME_TYPE = '1'                  		" \
			"											 THEN '400000'                          		" \
			"									 	 /* 계좌이체 - 자행이체 - 시간외 */         		" \
			"										 WHEN DEAL_TIME_TYPE = '2'                  		" \
			"											 THEN '400001'                          		" \
			"										 ELSE DEAL_TYPE||DEAL_CLSS||TRACK_NO				" \
			"									END                                             		" \
			"							ELSE                                                    		" \
			"								    /* 계좌이체 - 타행이체 - 시간내 */              		" \
			"									CASE WHEN DEAL_TIME_TYPE = '1'                  		" \
			"											 THEN '400020'                          		" \
			"									 	 /* 계좌이체  - 타행이체 - 시간외 */        		" \
			"										 WHEN DEAL_TIME_TYPE = '2'                  		" \
			"											 THEN '400021'                          		" \
			"										 ELSE DEAL_TYPE||DEAL_CLSS||TRACK_NO				" \
			"									END                                             		" \
			"						END                                                         		" \
			"			ELSE DEAL_TYPE||DEAL_CLSS||TRACK_NO                                    	 		" \
			"		END AS DEAL_TYPE,                                                          			" \
			"		DECODE( NET_ORG_CD, '081', 'J96' || MAC_NO || 'N' || LPAD( ATM_DEAL_NO, 5, '0' ), 	" \
			"								   '0'|| DEAL_NO ) AS DEAL_NO,           					" \
			"		DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME,                                  		" \
			"		LPAD( DEAL_AMT, 12, '0' ) AS DEAL_AMT,                                      		" \
			"		DECODE(DEAL_STATUS, '0', '0', '1', '1', '2', '3', '3', '2') AS DEAL_STATUS  		" \
			"FROM	T_FN_NICE_TRAN                                                              		" \
			"WHERE	DEAL_DATE = '%s'                                                      				" \
			"AND	ORG_CD = '081'                                                       				" \
			"AND	ADMIS_ORG = 'B' 																	" \
			"AND   (DEAL_TYPE = '0' OR DEAL_TYPE = '4' )												" \
			"AND   NET_ORG_CD <> '020'																	",
			hPreDate);

	EXEC SQL PREPARE S9N FROM :hSQLmain;
	EXEC SQL DECLARE C9N CURSOR FOR S9N;
	EXEC SQL OPEN C9N;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetHNetTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetHNetTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	ncount = 0;
	lnTotalAmt = 0;

	fprintf( pfTran, "HB0001110000000J960000000%08s%*s\n", hPreDate, 27, " " );

	while (1)
	{
		EXEC SQL	FETCH	C9N	INTO 	hWorkType,
										hDataType,
										hDealType,
										hDealNo,
										hDealTime,
										hDealAmt,
										hDealStatus;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE C9N;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "%.*s%.*s%07ld%.*s%.*s%.*s%.*s%.*s%*s\n",
								6,	hWorkType,
								2,	hDataType,
								ncount+1,
								6,	hDealType,
								13,	hDealNo,
								6,	hDealTime,
								12,	hDealAmt,
								1,	hDealStatus,
								7,	" ");

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);

		ncount++;
    }
	EXEC SQL CLOSE C9N;

	fprintf( pfTran, "HB0001339999999J96%07ld%*s\n", ncount, 35, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+3, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);

	return 0;
}

/* 중국은련카드 */
int GetCUTranData(char *pTransDate, char *pFileName)
{
EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType[1+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[8+1];
	char	hDealAmt[10+1];
	char	hDeal2Amt[10+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];
	char	hBrandNm[1+1];
	char	hDealDate2[8+1];
	char	hPreDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[6+1];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00, sizeof( hDataType	 ) );
	memset( hDealDate   , 0x00, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00, sizeof( hDealAmt     ) );
	memset( hDeal2Amt   , 0x00, sizeof( hDeal2Amt    ) );
	memset( hDealStatus , 0x00, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00, sizeof( hDealNo      ) );
	memset( hBrandNm    , 0x00, sizeof( hBrandNm     ) );
	memset( hDealDate2  , 0x00, sizeof( hDealDate2   ) );
	memset( hPreDate    , 0x00, sizeof( hPreDate     ) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCUTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	/* 20120625 일 전송 할 경우 만 20일 거래(전송일자 21일) 데이터의 일부를 포함하도록 함.
	당일 이부분 삭제 해야 함
	if( memcmp( pTransDate, "20120625", 8 ) == 0 )
	{
		sprintf(hSQLmain,
			"SELECT 'D' AS DATA_TYPE, 												" \
			"	  	SUBSTR(DEAL_DATE, 3, 6) AS DEAL_DATE, 						    " \
			"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, 					    " \
			"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || 						    " \
			"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, 			    " \
			"	   	MAC_NO, 													    " \
			"	   	LPAD(DEAL_AMT/10000, 7, '0') AS DEAL_AMT, 					    " \
			"	   	LPAD(DEAL_AMT/10000, 6, '0') AS DEAL2_AMT, 					    " \
			"	   	DEAL_STATUS, 												    " \
			"		'6', 														    " \
			"		SUBSTR(DEAL_YEAR, 4, 1) || 									    " \
			"			LPAD(TRUNC(TO_DATE(DEAL_DATE, 'YYYYMMDD')) -  			    " \
			"				TO_DATE(DEAL_YEAR || '0101', 'YYYYMMDD') + 1, 3, 0) ||  " \
			"			SUBSTR(DEAL_NO, 5, 8) AS CU_DEAL_NO,                        " \
			"	   	DEAL_DATE AS DEAL_DATE2 									    " \
			"FROM   T_FN_NICE_TRAN 												    " \
			"WHERE  DEAL_DATE = '20120620' 											" \
			"AND	ORG_CD = '0CU'                                                  " \
			"AND SUBSTR(DEAL_NO, 5, 8) IN ('20178361'                               " \
			",'20178665'                                                            " \
			",'20177753'                                                            " \
			",'20174678'                                                            " \
			",'20174692'                                                            " \
			",'20175084'                                                            " \
			",'20172785'                                                            " \
			",'20200010'                                                            " \
			",'20198241'                                                            " \
			",'20196878'                                                            " \
			",'20190998'                                                            " \
			",'20190470'                                                            " \
			",'20188879'                                                            " \
			",'20188740'                                                            " \
			",'20188824'                                                            " \
			",'20186186'                                                            " \
			",'20188201'                                                            " \
			",'20188408'                                                            " \
			",'20185544'                                                            " \
			",'20184608'                                                            " \
			",'20189134'                                                            " \
			",'20182103'                                                            " \
			",'20182312'                                                            " \
			",'20182497'                                                            " \
			",'20178611'                                                            " \
			",'20178119'                                                            " \
			",'20171570'                                                            " \
			",'20204260'                                                            " \
			",'20205976'                                                            " \
			",'20225249'                                                            " \
			",'20224236'                                                            " \
			",'20223529'                                                            " \
			",'20222227'                                                            " \
			",'20221293'                                                            " \
			",'20269167'                                                            " \
			",'20269031'                                                            " \
			",'20264298'                                                            " \
			",'20264078'                                                            " \
			",'20263549'                                                            " \
			",'20262514'                                                            " \
			",'20262657'                                                            " \
			",'20172658'                                                            " \
			",'20159572'                                                            " \
			",'20159758'                                                            " \
			",'20160776'                                                            " \
			",'20163275'                                                            " \
			",'20163477'                                                            " \
			",'20324262'                                                            " \
			",'20329624'                                                            " \
			",'20329145'                                                            " \
			",'20339623'                                                            " \
			",'20334891'                                                            " \
			")                                                                      " \
			"union all                                                              " \
			"SELECT 'D' AS DATA_TYPE, 												" \
			"	  	SUBSTR(DEAL_DATE, 3, 6) AS DEAL_DATE, 						    " \
			"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, 					    " \
			"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || 						    " \
			"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, 			    " \
			"	   	MAC_NO, 													    " \
			"	   	LPAD(DEAL_AMT/10000, 7, '0') AS DEAL_AMT, 					    " \
			"	   	LPAD(DEAL_AMT/10000, 6, '0') AS DEAL2_AMT, 					    " \
			"	   	DEAL_STATUS, 												    " \
			"		'6', 														    " \
			"		SUBSTR(DEAL_YEAR, 4, 1) || 									    " \
			"			LPAD(TRUNC(TO_DATE(DEAL_DATE, 'YYYYMMDD')) -  			    " \
			"				TO_DATE(DEAL_YEAR || '0101', 'YYYYMMDD') + 1, 3, 0) ||  " \
			"			SUBSTR(DEAL_NO, 5, 8) AS CU_DEAL_NO,                        " \
			"	   	DEAL_DATE AS DEAL_DATE2 									    " \
			"FROM   T_FN_NICE_TRAN 												    " \
			"WHERE  DEAL_DATE = '%s' 											    " \
			"AND	ORG_CD = '0CU' 												    " \
			"AND    DEAL_TYPE = '0' 											    " \
			"AND    DEAL_CLSS = '1410' 											    " \
			"AND	ADMIS_ORG = 'B' 											    " \
			"AND    DEAL_STATUS = '0'												",
		hPreDate);
	}
	else
	{
	*/
		sprintf(hSQLmain,
				"SELECT 'D' AS DATA_TYPE, 												" \
				"	  	SUBSTR(DEAL_DATE, 3, 6) AS DEAL_DATE, 						    " \
				"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, 					    " \
				"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || 						    " \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, 			    " \
				"	   	MAC_NO, 													    " \
				"	   	LPAD(DEAL_AMT/10000, 7, '0') AS DEAL_AMT, 					    " \
				"	   	LPAD(DEAL_AMT/10000, 6, '0') AS DEAL2_AMT, 					    " \
				"	   	DEAL_STATUS, 												    " \
				"		'6', 														    " \
				"		SUBSTR(DEAL_YEAR, 4, 1) || 									    " \
				"			LPAD(TRUNC(TO_DATE(DEAL_DATE, 'YYYYMMDD')) -  			    " \
				"				TO_DATE(DEAL_YEAR || '0101', 'YYYYMMDD') + 1, 3, 0) ||  " \
				"			SUBSTR(DEAL_NO, 5, 8) AS CU_DEAL_NO,                        " \
				"	   	DEAL_DATE AS DEAL_DATE2 									    " \
				"FROM   T_FN_NICE_TRAN 												    " \
				"WHERE  DEAL_DATE = '%s' 											    " \
				"AND	ORG_CD = '0CU' 												    " \
				"AND    DEAL_TYPE = '0' 											    " \
				"AND    DEAL_CLSS = '1410' 											    " \
				"AND	ADMIS_ORG = 'B' 											    " \
				"AND    DEAL_STATUS = '0'												",
				hPreDate);
	/*}*/

	EXEC SQL PREPARE SCU FROM :hSQLmain;
	EXEC SQL DECLARE CCU CURSOR FOR SCU;
	EXEC SQL OPEN CCU;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetCUTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetCUTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	ncount = 0;
	lnTotalAmt = 0;

	memset( szDate, 0x00, sizeof(szDate) );

	memcpy( szDate, &hPreDate[2], 6 );

	fprintf( pfTran, "H%sATM%6s6%*s\n", szDate, "NICE", 83, " " );

	while (1)
	{
		EXEC SQL	FETCH	CCU	INTO 	hDataType,
										hDealDate,
										hDealTime,
										hAccountNo,
										hMacNo,
										hDealAmt,
										hDeal2Amt,
										hDealStatus,
										hBrandNm,
										hDealNo,
										hDealDate2;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CCU;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
				1, hDataType, 6, hDealDate,	6, hDealTime, 19, hAccountNo, 8, hMacNo,
									7, hDealAmt, 6, hDeal2Amt, 1, hDealStatus,
									1, hBrandNm, 12, hDealNo, 8, hDealDate2, 25, " ");

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);

		ncount++;
    }
	EXEC SQL CLOSE CCU;

	fprintf( pfTran, "T%06d%013ld%*s\n", ncount, lnTotalAmt, 80, " " );

	fclose(pfTran);

	return 0;
}



/* 씨티카드 */
int GetCityTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType[1+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[8+1];
	char	hDealAmt[10+1];
	char	hDeal2Amt[10+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];
	char	hBrandNm[1+1];
	char	hDealDate2[8+1];
	char	hPreActDate[8+1];
	char	hPreDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00	, sizeof( hDataType	 ) );
	memset( hDealDate   , 0x00	, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00	, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00	, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00	, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00	, sizeof( hDealAmt     ) );
	memset( hDeal2Amt   , 0x00	, sizeof( hDeal2Amt    ) );
	memset( hDealStatus , 0x00	, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00	, sizeof( hDealNo      ) );
	memset( hBrandNm    , 0x00	, sizeof( hBrandNm     ) );
	memset( hDealDate2  , 0x00	, sizeof( hDealDate2   ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));


	/* 전송일이 휴일면 전송일을 전송일이 영업일이면 전 영업일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCityTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCityTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 씨티카드 휴일에는 전송하지 않는다. */
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetCityTranData] 휴일 전송 안함 [%s]\n", pTransDate);
		return -2;
	}

 	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCityTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCityTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}


 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCityTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}


	memcpy( szDate, hPreDate, 8 );

	ncount = 0;
	lnTotalAmt = 0;


	fprintf( pfTran, "1NIC%s000000%*s\n", pTransDate, 52, " " );

	while(1)
	{

		sprintf(hSQLmain,
				"SELECT '2' AS DATA_TYPE, "										\
				"	  	DEAL_DATE, "											\
				"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, "			\
				"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || "					\
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, "	\
				"	   	MAC_NO, "												\
				"	   	LPAD(DEAL_AMT/10000, 7, '0') AS DEAL_AMT, "				\
				"	   	LPAD(DEAL_AMT/10000, 7, '0') AS DEAL2_AMT, "			\
				"	   	DEAL_STATUS, "											\
				"	   	DEAL_NO "												\
				"FROM   T_FN_NICE_TRAN "										\
				"WHERE  DEAL_DATE = '%s' "										\
				"AND	ORG_CD = '0HM' "											\
				"AND    DEAL_TYPE = '0' "										\
				"AND    DEAL_CLSS = '1300' "									\
				"AND	ADMIS_ORG = 'B' 										" \
				"AND    DEAL_STATUS = '0' ",
				szDate);

		EXEC SQL PREPARE SCT FROM :hSQLmain;
		EXEC SQL DECLARE CCT CURSOR FOR SCT;
		EXEC SQL OPEN CCT;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCityTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetCityTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		while (1)
		{
			EXEC SQL	FETCH	CCT	INTO 	hDataType,
											hDealDate,
											hDealTime,
											hAccountNo,
											hMacNo,
											hDealAmt,
											hDeal2Amt,
											hDealStatus,
											hDealNo;
			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CCT;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
					1, hDataType, 8, hDealDate,	6, hDealTime, 16, hAccountNo, 4, hMacNo,
										7, hDealAmt, 7, hDeal2Amt, 1, hDealStatus,
										12, hDealNo, 8, " ");

			lnTotalAmt = lnTotalAmt + atol(hDealAmt);

			ncount++;
	    }
		EXEC SQL CLOSE CCT;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		logger("DealDate[%s]-PreDate[%s]-preActDate[%s]\n", szDate, hPreDate, hPreActDate);
		if( sqlca.sqlcode )
		{
			logger(">>> [GetCityTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}
	fprintf( pfTran, "3%08d%013ld%*s\n", ncount, lnTotalAmt, 48, " " );

	fclose(pfTran);
	return 0;
}


/* LG카드 */
int GetLGTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType[1+1];
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[8+1];
	char	hDealAmt[10+1];
	char	hDeal2Amt[10+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];
	char	hBrandNm[1+1];
	char	hDealDate2[8+1];
	char	hPreActDate[8+1];
	char	hPreDate[8+1];
	char	hTradeType[2+1];

	char	hFirstDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00	, sizeof( hDataType	 ) );
	memset( hDealDate   , 0x00	, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00	, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00	, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00	, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00	, sizeof( hDealAmt     ) );
	memset( hDeal2Amt   , 0x00	, sizeof( hDeal2Amt    ) );
	memset( hDealStatus , 0x00	, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00	, sizeof( hDealNo      ) );
	memset( hBrandNm    , 0x00	, sizeof( hBrandNm     ) );
	memset( hDealDate2  , 0x00	, sizeof( hDealDate2   ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));


	/* 전송일이 휴일면 전송일을 전송일이 영업일이면 전 영업일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetLGTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetLGTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* LG카드 휴일에는 전송하지 않는다. */
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetLGTranData] 휴일 전송 안함 [%s]\n", pTransDate);
		return -2;
	}

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetLGTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetLGTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetLGTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;
	lnTotalAmt = 0;


	fprintf( pfTran, "H%8s%8s%8s96%*s\n", pTransDate, hPreActDate, szDate, 43, " " );

	while(1)
	{

		sprintf(hSQLmain,
				"SELECT 'D' AS DATA_TYPE, "										\
				"		'01',	"												\
				"	  	DEAL_DATE, "											\
				"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, "			\
				"		'89'||SUBSTR(DEAL_NO, 3, LENGTH(DEAL_NO)-2), "			\
				"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || "					\
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, "	\
				"	   	LPAD(DEAL_AMT, 7, '0') AS DEAL_AMT, "					\
				"	   	MAC_NO "												\
				"FROM   T_FN_NICE_TRAN "										\
				"WHERE  DEAL_DATE = '%s' "										\
				"AND	ORG_CD = '0LG' "											\
				"AND    DEAL_TYPE = '0' "										\
				"AND    DEAL_CLSS = '1300' "									\
				"AND	ADMIS_ORG = 'B' 										" \
				"AND    DEAL_STATUS = '0' ",
				szDate);

		EXEC SQL PREPARE SLG FROM :hSQLmain;
		EXEC SQL DECLARE CLG CURSOR FOR SLG;
		EXEC SQL OPEN CLG;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetLGTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetLGTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		while (1)
		{
			EXEC SQL	FETCH	CLG	INTO 	hDataType,
											hTradeType,
											hDealDate,
											hDealTime,
											hDealNo,
											hAccountNo,
											hDealAmt,
											hMacNo;
			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CLG;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
					1, hDataType, 2, hTradeType, 8, hDealDate,	6, hDealTime, 12, hDealNo,
										16, hAccountNo, 7, hDealAmt, 4, hMacNo, 14, " ");

			lnTotalAmt = lnTotalAmt + atol(hDealAmt);

			ncount++;
	    }
		EXEC SQL CLOSE CLG;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetLGTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}
	fprintf( pfTran, "T%06d%013ld%*s\n", ncount, lnTotalAmt, 50, " " );

	fclose(pfTran);
	return 0;
}


/* 신한카드론 */
int GetLCTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType		[2+1];
	char	hDealNo			[12+1];
	char	hAccountNo		[25+1];
	char	hDealDate		[8+1];
	char	hDealTime		[6+1];
	char	hDealAmt		[13+1];
	char	hTradeType		[1+1];
	char	hTransOrgCd		[2+1];
	char	hTransAccountNo	[20+1];
	char	hDealStatus		[1+1];
	char	hPreActDate		[8+1];
	char	hPreDate		[8+1];

	char	hFirstDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];

	long	lnTotalAmt;
	long	lnTotalCnt;
	long	lnNormalOutCnt;
	long	lnNormalOutAmt;
	long	lnNormalTransCnt;
	long	lnNormalTransAmt;
	long	lnEtcCnt;
	long	lnEtcAmt;
	long	lnErrCnt;
	long	lnErrAmt;

	FILE	*pfTran;

	memset( hDataType		, 0x00	, sizeof(hDataType		    ) );
	memset( hDealNo			, 0x00	, sizeof(hDealNo			  ) );
	memset( hAccountNo		, 0x00	, sizeof(hAccountNo		      ) );
	memset( hDealDate		, 0x00	, sizeof(hDealDate		      ) );
	memset( hDealTime		, 0x00	, sizeof(hDealTime		      ) );
	memset( hDealAmt		, 0x00	, sizeof(hDealAmt		      ) );
	memset( hTradeType		, 0x00	, sizeof(hTradeType		      ) );
	memset( hTransOrgCd		, 0x00	, sizeof(hTransOrgCd		  ) );
	memset( hTransAccountNo	, 0x00	, sizeof(hTransAccountNo	  ) );
	memset( hDealStatus		, 0x00	, sizeof(hDealStatus		  ) );

	memset( hPreActDate		, 0x00	, sizeof(hPreActDate		  ) );
	memset( hPreDate		, 0x00	, sizeof(hPreDate		      ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));



	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetLGTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetLGTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetLGTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	lnTotalAmt       = 0;
	lnTotalCnt       = 0;
	lnNormalOutCnt   = 0;
	lnNormalOutAmt   = 0;
	lnNormalTransCnt = 0;
	lnNormalTransAmt = 0;
	lnEtcCnt = 0;
	lnEtcAmt = 0;
	lnErrCnt         = 0;
	lnErrAmt         = 0;



	fprintf( pfTran, "HD%8s%8s89%*s\n", hPreDate, pTransDate, 180, " " );

	sprintf(hSQLmain,
			"SELECT 'BD' AS DATA_TYPE, "									\
			"		'89'||SUBSTR(DEAL_NO, 3, LENGTH(DEAL_NO)-2), "			\
			"	   	FC_FN_SECURITY(INST_JIJUM_CD, '2') || "					\
			"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO, "	\
			"	  	DEAL_DATE, "											\
			"	   	DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME, "			\
			"	   	LPAD(DEAL_AMT, 13, '0') AS DEAL_AMT, "					\
			"		DECODE(DEAL_TYPE, '0', '1', '4', '2', '3' ), "			\
			"		SUBSTR(TRANS_ORG_CD, 3, 2), "							\
			"	   	FC_FN_SECURITY(TRANS_JIJUM_CD, '2') || "					\
			"			FC_FN_SECURITY(TRANS_ACCOUNT_NO, '2') AS ACCOUNT_NO, "	\
			"	    DECODE( DEAL_STATUS, '0', 'N', 'Y' ) "					\
			"FROM   T_FN_NICE_TRAN "										\
			"WHERE  DEAL_DATE = '%s' "										\
			"AND	ORG_CD = '0LC' "										\
			"AND    DEAL_TYPE IN ('0', '4', '5') "							\
			"AND    DEAL_CLSS = '4010' "									\
			"AND    DEAL_STATUS IN ( '0', '1', '2' ) ",
			szDate);

	EXEC SQL PREPARE SLC FROM :hSQLmain;
	EXEC SQL DECLARE CLC CURSOR FOR SLC;
	EXEC SQL OPEN CLC;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetLCTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetLCTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}


	while (1)
	{
		EXEC SQL	FETCH	CLC	INTO 	hDataType,
										hDealNo,
										hAccountNo,
										hDealDate,
										hDealTime,
										hDealAmt,
										hTradeType,
										hTransOrgCd,
										hTransAccountNo,
										hDealStatus;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CLC;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "%.*s89%.*s%.*s%.*s%.*s%.*s%.*s00  %.*s%.*s%.*s%.*s%*s\n",
				2, hDataType, 12, hDealNo, 16, hAccountNo, 8, hDealDate, 6, hDealTime, 13, hDealAmt,
				1, hTradeType, 6, hDealTime, 2, hTransOrgCd, 20, hTransAccountNo, 1, hDealStatus,
				107, " ");

		lnTotalAmt = lnTotalAmt + atol(hDealAmt);
		lnTotalCnt++;

		/* 정상건 */
		if( hDealStatus[0] == 'N' )
		{
			/* 지급건 */
			if( hTradeType[0] == '1' )
			{
				lnNormalOutAmt = lnNormalOutAmt + atol(hDealAmt);
				lnNormalOutCnt++;
			}
			else if( hTradeType[0] == '4' )/* 이체건 */
			{
				lnNormalTransAmt = lnNormalTransAmt + atol(hDealAmt);
				lnNormalTransCnt++;
			}
			else /* 약정 */
			{
				lnEtcAmt = lnEtcAmt + atol(hDealAmt);
				lnEtcCnt++;
			}
		}
		else /* 오류건 */
		{
			lnErrAmt = lnErrAmt + atol(hDealAmt);
			lnErrCnt++;
		}
    }
	EXEC SQL CLOSE CLC;

	fprintf( pfTran, "TR89%010d%013d%010d%013d%010d%013d%010d%013d%010d%013d%*s\n",
			lnTotalCnt ,lnTotalAmt ,lnNormalOutCnt ,lnNormalOutAmt ,
			lnNormalTransCnt ,lnNormalTransAmt ,lnEtcCnt ,lnEtcAmt ,
			lnErrCnt ,lnErrAmt, 81, " " );

	fclose(pfTran);
	return 0;
}

/* 농협 */
int GetNongHTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[8+1];
	char	hDealAmt[12+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];

	char	hTradeType[6+1];

	char	hJoinType[2+1];
	char	hJoinMojum[5+1];
	char	hJoinCd[2+1];
	char	hLastType[4+1];
	char	hOrgRespCd[2+1];
	char	hOrgCd[2+1];
	char	hFee[5+1];
	char	hTransOrgCd[2+1];
	char	hTransAccountNo[19+1];
	char	hAtmType[2+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];

	char	hTransDate6[6+1];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDealDate   , 0x00	, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00	, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00	, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00	, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00	, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00	, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00	, sizeof( hDealNo      ) );


	memset( hJoinType	, 0x00  , sizeof( hJoinType    ) );
	memset( hJoinMojum  , 0x00  , sizeof( hJoinMojum   ) );
	memset( hJoinCd     , 0x00  , sizeof( hJoinCd      ) );
	memset( hLastType   , 0x00  , sizeof( hLastType    ) );
	memset( hOrgRespCd  , 0x00  , sizeof( hOrgRespCd   ) );
	memset( hOrgCd      , 0x00  , sizeof( hOrgCd       ) );
	memset( hFee        , 0x00  , sizeof( hFee         ) );
	memset( hTransOrgCd , 0x00  , sizeof( hTransOrgCd  ) );
	memset( hAtmType    , 0x00  , sizeof( hAtmType     ) );
	memset( hTransAccountNo , 0x00  , sizeof( hTransAccountNo  ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );
	memset( hTransDate6	, 0x00	, sizeof(hTransDate6) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

/* 임시.. 전송일 10일 거래일 6,7,8,9일 데이터 요청
memcpy( hPreActDate, "20061006", 8 );
*/

	/* 전송일이 휴일면 전송일을.. 전송일이 영업일이면 전 영업일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetNongHTranData][%s]-[%s] 휴일 전송 하지 않음 \n", pTransDate, hPreActDate);
		return -2;
	}

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetNongHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;
	lnTotalAmt = 0;

	memcpy( hTransDate6, &pTransDate[2], 6 );

	fprintf( pfTran, "ATM03311000000011960000000%6s%*s\n", hTransDate6, 138, " " );


	while(1)
	{

		sprintf(hSQLmain,
				"SELECT T.DEAL_DATE, 											 							      	" \
				"	   	T.DEAL_HOUR||T.DEAL_MI||T.DEAL_SEC AS DEAL_TIME,                                          	" \
				"		T.DEAL_NO,                                                                                	" \
				"		DECODE(M.JOIN_CD, '011', '0', '1') AS JOIN_CD,                                             	" \
				"		'0' || LPAD(NVL(M.JOIN_MOJUM_CD, '0'), 4 , '0') AS JOIN_MOJUM_CD,                         	" \
				"		'96',                                                                                     	" \
				"		T.MAC_NO,                                                                                 	" \
				"		CASE WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31000' /* 잔액조회 */							      	" \
				"			 	  THEN '312400'                                                                   	" \
				"			 WHEN T.DEAL_TYPE||T.DEAL_CLSS = '01000' /* 예금인출 */							      	" \
				"			 	  THEN                                                                            	" \
				"				  	   CASE WHEN T.DEAL_TIME_TYPE = '1' /* 예금인출-시간내 */             	      	" \
				"					   			 THEN '012200'                                                    	" \
				"							WHEN T.DEAL_TIME_TYPE = '2' /* 예금인출-시간외 */                     	" \
				"								 THEN '012300'                                                    	" \
				"							ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO						      	" \
				"						END                                                                       	" \
				"			 /* 수취조회 */                                                                       	" \
				"			 WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31002'                                              	" \
				"			 	  THEN                                                                            	" \
				"				  	  /* 수취조회-자행이체 */                                                     	" \
				"					  CASE WHEN (T.TRANS_ORG_CD = '0011' OR T.TRANS_ORG_CD = '0012')                " \
				"					  	   		THEN                                                              	" \
				"							   	    /* 수취조회 - 자행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '312490'                                        	" \
				"									 	 /* 수취조회 - 자행이체 - 시간외 */                       	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '312590'                                        	" \
				"									ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                     	" \
				"									END                                                           	" \
				"							ELSE                                                                  	" \
				"								    /* 수취조회 - 타행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '312491'                                        	" \
				"									 	 /* 수취조회 - 타행이체 - 시간외 */                       	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '312591'                                        	" \
				"									ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                     	" \
				"									END                                                           	" \
				"						END                                                                       	" \
				"			/* 계죄이체 */                                                                        	" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '40000'                                               	" \
				"				 THEN                                                                             	" \
				"				 	 /* 계좌이체 - 자행 */                                                        	" \
				"					 CASE WHEN (T.TRANS_ORG_CD = '0011' OR T.TRANS_ORG_CD = '0012')                 " \
				"					  	   		THEN                                                              	" \
				"							   	    /* 계좌이체 - 자행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '012290'                                        	" \
				"									 	 /* 계좌이체 - 자행이체 - 시간외 */                       	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '012390'                                        	" \
				"										 ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                	" \
				"									END                                                           	" \
				"							ELSE                                                                  	" \
				"								    /* 계좌이체 - 타행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '012291'                                        	" \
				"									 	 /* 계좌이체  - 타행이체 - 시간외 */                      	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '012391'                                        	" \
				"										 ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                	" \
				"									END																" \
				"						END                                                                       	" \
				"			/* 통장정리조회 */                                                                     	" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31003'													" \
                "				THEN '312440'																		" \
				"			/* 통장정리 */																			" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31004'													" \
                "				THEN '012240'																		" \
				"			/* 공과금납부조회 */																	" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '30001'													" \
               	"				THEN																				" \
               	"				/* MS 거래 */																		" \
               	"				CASE WHEN T.TRACK_NO = '3'															" \
               	"						THEN '312470'																" \
               	"					 /* IC 거래 */																	" \
               	"					WHEN T.TRACK_NO = '4'															" \
               	"						 THEN '312460'																" \
               	"					ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO										" \
				"				END																					" \
				"			/* 공과금납부 */																		" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '50001'													" \
				"				THEN																				" \
                "				/* MS 거래 */																		" \
                "				CASE WHEN T.TRACK_NO = '3'															" \
                "						THEN '012270'																" \
                "					/* IC 거래 */																	" \
                "					WHEN T.TRACK_NO = '4'															" \
                "						THEN '012260'																" \
                "					ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO										" \
				"				END                         														" \
				"			ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO												" \
				"		END AS TRADE_TYPE,                                              							" \
				"		CASE WHEN T.DEAL_STATUS = '0'                                   							" \
				"				THEN	 '0210'																		" \
				"			WHEN T.DEAL_STATUS = '1' 																" \
				"				THEN '0430'                                            								" \
				"			WHEN T.DEAL_STATUS = '2'                      											" \
				"			 	THEN																				" \
				"			 		CASE WHEN T.DEAL_TYPE = '0'														" \
				"				 	     	THEN                                                    				" \
				"								CASE WHEN T.ORG_RESPONSE_CD = '11'									" \
				"										THEN '0430'													" \
				"								ELSE '0200'															" \
				"								END																	" \
				"				    	 WHEN (T.DEAL_TYPE = '3' OR T.DEAL_TYPE = '4' OR T.DEAL_TYPE = '5')			" \
				"				            THEN																	" \
				"				            	'0200'																" \
				"					END																				" \
				"			 WHEN T.DEAL_STATUS = '3'																" \
				"			 	  THEN																				" \
				"			 	       CASE WHEN T.DEAL_TYPE = '0'													" \
				"			 	             THEN																	" \
				"     								CASE WHEN T.REFUSE_CD = '608'									" \
				"     								 		THEN '0430'												" \
				"     									   ELSE														" \
				"    									   	    CASE WHEN T.ORG_RESPONSE_CD <> '11'					" \
				"     								  	   			 	  THEN '0210'								" \
				"     								  	   			 ELSE '0200'									" \
				"     											END													" \
				"     								  END															" \
				"         					WHEN (T.DEAL_TYPE = '3' OR T.DEAL_TYPE = '4' OR T.DEAL_TYPE = '5')		" \
				"      						      THEN																" \
				"      						          '0210'														" \
				"      		           		END																		" \
				"			END AS LAST_TYPE,                                                                       " \
				"       CASE WHEN T.ORG_CD <> '011' AND T.ORG_CD <> '012'											" \
				"            THEN DECODE( T.DEAL_STATUS, '0', '00', RPAD(RTRIM(T.ORG_RESPONSE_CD), 2, '9'))			" \
				"            ELSE RPAD(RTRIM(T.ORG_RESPONSE_CD), 2, '9')											" \
				"       END AS ORG_RESPONSE_CD,																		" \
				"		CASE WHEN (ASCII(SUBSTR(T.ORG_CD, 2, 1)) >= 48 AND 											" \
				"						ASCII(SUBSTR(T.ORG_CD,2, 1)) <= 57)                                      	" \
				"			 	  AND (ASCII(SUBSTR(T.ORG_CD, 3, 1)) >= 48 AND                                    	" \
				"			 	  		ASCII(SUBSTR(T.ORG_CD, 3, 1)) <= 57)                                      	" \
				"				  THEN substr(T.ORG_CD, 2,2)                                                       	" \
				"			 ELSE '96'                                                                            	" \
				"		END AS ORG_CD,                                                                            	" \
				"		FC_FN_SECURITY(T.INST_JIJUM_CD, '2') || 					                              	" \
				"			FC_FN_SECURITY(T.ACCOUNT_NO, '2') AS ACCOUNT_NO, 	                                  	" \
				"		LPAD(T.DEAL_AMT, 12, '0') AS DEAL_AMT,                                                    	" \
				"		CASE WHEN /*T.DEAL_TYPE = '0' OR T.DEAL_TYPE = '4'*/										" \
				"				  T.DEAL_TYPE = '0'	AND T.ORG_CD <> '011' 											" \
				"			      AND T.ORG_CD <> '012'	AND T.DEAL_STATUS = '0'										" \
				"			 THEN LPAD( '810', 5, '0')																" \
				"			 WHEN T.DEAL_TYPE <> '3'																" \
				"			 THEN LPAD(DECODE(T.DEAL_STATUS, '0', T.CUST_FEE + T.BANK_FEE, 0), 5, '0')       		" \
				"			 ELSE LPAD('0', 5, '0')                                                               	" \
				"		END AS FEE,                                                                               	" \
				"		SUBSTR(T.TRANS_ORG_CD, 3, 2),                                                             	" \
				"		FC_FN_SECURITY(T.TRANS_JIJUM_CD, '2') || 					                              	" \
				"			FC_FN_SECURITY(T.TRANS_ACCOUNT_NO, '2') AS TRANS_ACCOUNT_NO,                          	" \
				"		CASE WHEN C.MAC_MODEL = '1300'																" \
				"			 	  THEN '01'																			" \
				"			 WHEN C.MAC_MODEL = '1200'																" \
				"			 	  THEN '03'																			" \
				"		     ELSE																					" \
				"			 	  '02'																				" \
				"		END AS ATM_TYPE                                                                             " \
				"FROM	T_FN_NICE_TRAN T,                                                                         	" \
				"		T_CT_NICE_MAC  M,                                                                          	" \
				"		T_CM_MAC	   C																			" \
				"WHERE	T.MAC_NO = M.MAC_NO				                                                          	" \
				"AND    T.DEAL_DATE = '%s'                                                                       	" \
				"AND	T.ADMIS_ORG = 'B' 																			" \
				"AND	M.JOIN_CD IN ('011', '012') 													      		" \
				"AND	C.MAC_NO = T.MAC_NO																			" \
				"AND	C.JIJUM_CD = '9600'																			" \
				"AND    C.ORG_CD = '096'																				",
				szDate);

		EXEC SQL PREPARE S2 FROM :hSQLmain;
		EXEC SQL DECLARE C2 CURSOR FOR S2;
		EXEC SQL OPEN C2;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetNongHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetNongHTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		while (1)
		{
			EXEC SQL	FETCH	C2	INTO 	hDealDate,
											hDealTime,
											hDealNo,
											hJoinType,
											hJoinMojum,
											hJoinCd,
											hMacNo,
											hTradeType,
											hLastType,
											hOrgRespCd,
											hOrgCd,
											hAccountNo,
											hDealAmt,
											hFee,
											hTransOrgCd,
											hTransAccountNo,
											hAtmType;
			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE C2;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "ATM03322%07ld", ncount+1 );
			fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
					8, hDealDate,	6, hDealTime, 12, hDealNo, 1, hJoinType,
					5, hJoinMojum, 2, hJoinCd, 4, hMacNo, 6, hTradeType,
					4, hLastType, 2, hOrgRespCd, 2, hOrgCd, 17, hAccountNo,
					12, hDealAmt, 5, hFee, 2, hTransOrgCd, 14, hTransAccountNo,
					2, hAtmType, 51, " ");

			lnTotalAmt = lnTotalAmt + atol(hDealAmt);

			ncount++;
	    }
		EXEC SQL CLOSE C2;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetNongHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}
	fprintf( pfTran, "ATM0333399999991196%07ld%.8s%*s\n", ncount, pTransDate, 136, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+2+2, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}

/* 농협 */
int GetNongHTranData_dasi(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[8+1];
	char	hDealAmt[12+1];
	char	hDealStatus[1+1];
	char	hDealNo[12+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];

	char	hTradeType[6+1];

	char	hJoinType[2+1];
	char	hJoinMojum[5+1];
	char	hJoinCd[2+1];
	char	hLastType[4+1];
	char	hOrgRespCd[2+1];
	char	hOrgCd[2+1];
	char	hFee[5+1];
	char	hTransOrgCd[2+1];
	char	hTransAccountNo[19+1];
	char	hAtmType[2+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];

	char	hTransDate6[6+1];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDealDate   , 0x00	, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00	, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00	, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00	, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00	, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00	, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00	, sizeof( hDealNo      ) );


	memset( hJoinType	, 0x00  , sizeof( hJoinType    ) );
	memset( hJoinMojum  , 0x00  , sizeof( hJoinMojum   ) );
	memset( hJoinCd     , 0x00  , sizeof( hJoinCd      ) );
	memset( hLastType   , 0x00  , sizeof( hLastType    ) );
	memset( hOrgRespCd  , 0x00  , sizeof( hOrgRespCd   ) );
	memset( hOrgCd      , 0x00  , sizeof( hOrgCd       ) );
	memset( hFee        , 0x00  , sizeof( hFee         ) );
	memset( hTransOrgCd , 0x00  , sizeof( hTransOrgCd  ) );
	memset( hAtmType    , 0x00  , sizeof( hAtmType     ) );
	memset( hTransAccountNo , 0x00  , sizeof( hTransAccountNo  ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );
	memset( hTransDate6	, 0x00	, sizeof(hTransDate6) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

/* 임시.. 전송일 10일 거래일 6,7,8,9일 데이터 요청
memcpy( hPreActDate, "20061006", 8 );
*/

	/* 전송일이 휴일면 전송일을.. 전송일이 영업일이면 전 영업일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetNongHTranData][%s]-[%s] 휴일 전송 하지 않음 \n", pTransDate, hPreActDate);
		return -2;
	}

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetNongHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;
	lnTotalAmt = 0;

	memcpy( hTransDate6, &pTransDate[2], 6 );

	fprintf( pfTran, "ATM03311000000011960000000%6s%*s\n", hTransDate6, 138, " " );


	while(1)
	{


		sprintf(hSQLmain,
				"SELECT T.DEAL_DATE, 											 							      	" \
				"	   	T.DEAL_HOUR||T.DEAL_MI||T.DEAL_SEC AS DEAL_TIME,                                          	" \
				"		T.DEAL_NO,                                                                                	" \
				"		DECODE(M.JOIN_CD, '011', '0', '1') AS JOIN_CD,                                             	" \
				"		'0' || LPAD(NVL(M.JOIN_MOJUM_CD, '0'), 4 , '0') AS JOIN_MOJUM_CD,                         	" \
				"		'96',                                                                                     	" \
				"		T.MAC_NO,                                                                                 	" \
				"		CASE WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31000' /* 잔액조회 */							      	" \
				"			 	  THEN '312400'                                                                   	" \
				"			 WHEN T.DEAL_TYPE||T.DEAL_CLSS = '01000' /* 예금인출 */							      	" \
				"			 	  THEN                                                                            	" \
				"				  	   CASE WHEN T.DEAL_TIME_TYPE = '1' /* 예금인출-시간내 */             	      	" \
				"					   			 THEN '012200'                                                    	" \
				"							WHEN T.DEAL_TIME_TYPE = '2' /* 예금인출-시간외 */                     	" \
				"								 THEN '012300'                                                    	" \
				"							ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO						      	" \
				"						END                                                                       	" \
				"			 /* 수취조회 */                                                                       	" \
				"			 WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31002'                                              	" \
				"			 	  THEN                                                                            	" \
				"				  	  /* 수취조회-자행이체 */                                                     	" \
				"					  CASE WHEN (T.TRANS_ORG_CD = '0011' OR T.TRANS_ORG_CD = '0012')                  	" \
				"					  	   		THEN                                                              	" \
				"							   	    /* 수취조회 - 자행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '312490'                                        	" \
				"									 	 /* 수취조회 - 자행이체 - 시간외 */                       	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '312590'                                        	" \
				"									ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                     	" \
				"									END                                                           	" \
				"							ELSE                                                                  	" \
				"								    /* 수취조회 - 타행이체 - 시간내 */                            		" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '312491'                                        	" \
				"									 	 /* 수취조회 - 타행이체 - 시간외 */                       		" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '312591'                                        	" \
				"									ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                     	" \
				"									END                                                           	" \
				"						END                                                                       	" \
				"			/* 계죄이체 */                                                                        	" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '40000'                                               	" \
				"				 THEN                                                                             	" \
				"				 	 /* 계좌이체 - 자행 */                                                        	" \
				"					 CASE WHEN (T.TRANS_ORG_CD = '0011' OR T.TRANS_ORG_CD = '0012')                   	" \
				"					  	   		THEN                                                              	" \
				"							   	    /* 계좌이체 - 자행이체 - 시간내 */                            		" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '012290'                                        	" \
				"									 	 /* 계좌이체 - 자행이체 - 시간외 */                       		" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '012390'                                        	" \
				"										 ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                	" \
				"									END                                                           	" \
				"							ELSE                                                                  	" \
				"								    /* 계좌이체 - 타행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '012291'                                        	" \
				"									 	 /* 계좌이체  - 타행이체 - 시간외 */                      	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '012391'                                        	" \
				"										 ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                	" \
				"									END								" \
				"						END                                                                       		" \
				"			/* 통장정리조회 */                                                                        	" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31003'						" \
                                "				THEN '312440'											" \
				"			/* 통장정리 */												" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31004'						" \
                                "				THEN '012240'											" \
				"			/* 공과금납부조회 */											" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '30001'						" \
                                "				THEN													" \
                                "				/* MS 거래 */											" \
                                "				CASE WHEN T.TRACK_NO = '3'								" \
                                "						THEN '312470'									" \
                                "					 /* IC 거래 */										" \
                                "					WHEN T.TRACK_NO = '4'								" \
                                "						 THEN '312460'									" \
                                "					ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO			" \
				"				END													" \
				"			/* 공과금납부 */											" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '50001'						" \
				"				THEN													" \
                                "				/* MS 거래 */											" \
                                "				CASE WHEN T.TRACK_NO = '3'								" \
                                "						THEN '012270'									" \
                                "					/* IC 거래 */										" \
                                "					WHEN T.TRACK_NO = '4'								" \
                                "						THEN '012260'									" \
                                "					ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO			" \
				"				END                         										" \
				"			ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO					" \
				"		END AS TRADE_TYPE,                                                                        		" \
				"		CASE WHEN T.DEAL_STATUS = '0'                                   " \
				"				THEN	 '0210'						"\
				"			WHEN T.DEAL_STATUS = '1' " \
				"				THEN '0430'                                               " \
				"			WHEN T.DEAL_STATUS = '2'                      " \
"							 	THEN									" \
"							 		CASE WHEN T.DEAL_TYPE = '0'" \
"    							 	     	THEN                                                                           " \
"            									CASE WHEN T.ORG_RESPONSE_CD = '11'                 " \
"            											THEN '0430'					" \
"            									ELSE '0200'								" \
"            									END											" \
"            					    	 WHEN (T.DEAL_TYPE = '3' OR T.DEAL_TYPE = '4' OR T.DEAL_TYPE = '5')	" \
"            					            THEN								" \
"            					            	'0200'            					                                 " \
"									END                                                                        " \
"							 WHEN T.DEAL_STATUS = '3'                                                              " \
"							 	  THEN						" \
"							 	       CASE WHEN T.DEAL_TYPE = '0'" \
"							 	               THEN                                                                          " \
"                   								CASE WHEN T.REFUSE_CD = '608'                                 " \
"                   								 		THEN '0430'                                                      " \
"                   									   ELSE                                                                  " \
 "                  									   	    CASE WHEN T.ORG_RESPONSE_CD <> '11'           " \
"                   								  	   			 	  THEN '0210'				" \
"                   								  	   			 ELSE '0200'					" \
"                   											END										" \
"                   								  END													"\
"                       					WHEN (T.DEAL_TYPE = '3' OR T.DEAL_TYPE = '4' OR T.DEAL_TYPE = '5')			" \
"                    						      THEN													" \
"                    						          '0210'													" \
"                    		            END  	                     						                                                                      " \
"							                                                                          " \
"						END AS LAST_TYPE,													" \
				"		RPAD(RTRIM(T.ORG_RESPONSE_CD), 2, '9'),                                                     " \
				"		CASE WHEN (ASCII(SUBSTR(T.ORG_CD, 2, 1)) >= 48 AND 						" \
				"						ASCII(SUBSTR(T.ORG_CD, 2, 1)) <= 57)                                      	" \
				"			 	  AND (ASCII(SUBSTR(T.ORG_CD, 3, 1)) >= 48 AND                                    	" \
				"			 	  		ASCII(SUBSTR(T.ORG_CD, 3, 1)) <= 57)                                      	" \
				"				  THEN SUBSTR(T.ORG_CD, 2,2)                                                          	" \
				"			 ELSE '96'                                                                            	" \
				"		END AS ORG_CD,                                                                            	" \
				"		FC_FN_SECURITY(T.INST_JIJUM_CD, '2') || 					                              	" \
				"			FC_FN_SECURITY(T.ACCOUNT_NO, '2') AS ACCOUNT_NO, 	                                  	" \
				"		LPAD(T.DEAL_AMT, 12, '0') AS DEAL_AMT,                                                    	" \
				"		CASE WHEN /*T.DEAL_TYPE = '0' OR T.DEAL_TYPE = '4'*/										" \
				"				  T.DEAL_TYPE <> '3'																" \
				"			 	  THEN LPAD(DECODE(T.DEAL_STATUS, '0', T.CUST_FEE + T.BANK_FEE, 0), 5, '0')       	" \
				"			 ELSE LPAD('0', 5, '0')                                                               	" \
				"		END AS FEE,                                                                               	" \
				"		SUBSTR(T.TRANS_ORG_CD, 3, 2),                                                             	" \
				"		FC_FN_SECURITY(T.TRANS_JIJUM_CD, '2') || 					                              	" \
				"			FC_FN_SECURITY(T.TRANS_ACCOUNT_NO, '2') AS TRANS_ACCOUNT_NO,                          	" \
				"		CASE WHEN C.MAC_MODEL = '1300'																" \
				"			 	  THEN '01'																			" \
				"			 WHEN C.MAC_MODEL = '1200'																" \
				"			 	  THEN '03'																			" \
				"		     ELSE																					" \
				"			 	  '02'																				" \
				"		END AS ATM_TYPE                                                                             " \
				"FROM	T_FN_NICE_TRAN T,                                                                         	" \
				"		T_CT_NICE_MAC  M,                                                                          	" \
				"		T_CM_MAC	   C																			" \
				"WHERE	T.MAC_NO = M.MAC_NO				                                                          	" \
				"AND    T.DEAL_DATE = '%s'                                                                       	" \
				"AND	T.ADMIS_ORG = 'B' 																			" \
				"AND	M.JOIN_CD IN ('011', '012') 														      		" \
				"AND	C.MAC_NO = T.MAC_NO																			" \
				"AND	C.JIJUM_CD = '9600'																			" \
				"AND    C.ORG_CD = '096'																				",
				szDate);

		EXEC SQL PREPARE S4 FROM :hSQLmain;
		EXEC SQL DECLARE C4 CURSOR FOR S4;
		EXEC SQL OPEN C4;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetNongHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetNongHTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		while (1)
		{
			EXEC SQL	FETCH	C4	INTO 	hDealDate,
											hDealTime,
											hDealNo,
											hJoinType,
											hJoinMojum,
											hJoinCd,
											hMacNo,
											hTradeType,
											hLastType,
											hOrgRespCd,
											hOrgCd,
											hAccountNo,
											hDealAmt,
											hFee,
											hTransOrgCd,
											hTransAccountNo,
											hAtmType;
			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE C4;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "ATM03322%07ld", ncount+1 );
			fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
					8, hDealDate,	6, hDealTime, 12, hDealNo, 1, hJoinType,
					5, hJoinMojum, 2, hJoinCd, 4, hMacNo, 6, hTradeType,
					4, hLastType, 2, hOrgRespCd, 2, hOrgCd, 17, hAccountNo,
					12, hDealAmt, 5, hFee, 2, hTransOrgCd, 14, hTransAccountNo,
					2, hAtmType, 51, " ");

			lnTotalAmt = lnTotalAmt + atol(hDealAmt);

			ncount++;
	    }
		EXEC SQL CLOSE C4;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetNongHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}
	fprintf( pfTran, "ATM0333399999991196%07ld%.8s%*s\n", ncount, pTransDate, 136, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+2+2, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}

/* 농협 */
int GetNongHTranData_NEW(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[8+1];
	char	hDealAmt[12+1];
	char	hDealStatus[1+1];
	char	hDealNo[13+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];

	char	hTradeType[6+1];

	char	hJoinType[2+1];
	char	hJoinMojum[6+1];
	char	hJoinCd[3+1];
	char	hLastType[4+1];
	char	hOrgRespCd[2+1];
	char	hOrgCd[3+1];
	char	hFee[5+1];
	char	hTransOrgCd[3+1];
	char	hTransAccountNo[19+1];
	char	hAtmType[2+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDealDate   , 0x00	, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00	, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00	, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00	, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00	, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00	, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00	, sizeof( hDealNo      ) );


	memset( hJoinType	, 0x00  , sizeof( hJoinType    ) );
	memset( hJoinMojum  , 0x00  , sizeof( hJoinMojum   ) );
	memset( hJoinCd     , 0x00  , sizeof( hJoinCd      ) );
	memset( hLastType   , 0x00  , sizeof( hLastType    ) );
	memset( hOrgRespCd  , 0x00  , sizeof( hOrgRespCd   ) );
	memset( hOrgCd      , 0x00  , sizeof( hOrgCd       ) );
	memset( hFee        , 0x00  , sizeof( hFee         ) );
	memset( hTransOrgCd , 0x00  , sizeof( hTransOrgCd  ) );
	memset( hAtmType    , 0x00  , sizeof( hAtmType     ) );
	memset( hTransAccountNo , 0x00  , sizeof( hTransAccountNo  ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

/* 임시.. 전송일 10일 거래일 6,7,8,9일 데이터 요청
memcpy( hPreActDate, "20061006", 8 );
*/

	/* 전송일이 휴일면 전송일을.. 전송일이 영업일이면 전 영업일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetNongHTranData][%s]-[%s] 휴일 전송 하지 않음 \n", pTransDate, hPreActDate);
		return -2;
	}

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetNongHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;
	lnTotalAmt = 0;


	fprintf( pfTran, "VC0033110000000011NC 0000000%8s%*s\n", hPreDate, 134, " " );

/* 20110609 기관응답코드를 N0, N1,N2 에 대해서도 정상으로 변환처리 */
	while(1)
	{

		sprintf(hSQLmain,
				"SELECT T.DEAL_DATE, 											 							      	" \
				"	   	T.DEAL_HOUR||T.DEAL_MI||T.DEAL_SEC AS DEAL_TIME,                                          	" \
				"		'NC'||DECODE(M.JOIN_CD, '0MS', 'B', 'I') || SUBSTR( T.DEAL_NO, 3, 10) AS DEAL_NO,			" \
				"		LPAD(NVL(M.JOIN_MOJUM_CD, '0'), 6 , '0') AS JOIN_MOJUM_CD,                         			" \
				"		'NC'||DECODE(M.JOIN_CD, '0MS', 'B', 'I') AS JOIN_ORG_CD,                                   	" \
				"		T.MAC_NO,                                                                                 	" \
				"		CASE WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31000' /* 잔액조회 */							      	" \
				"			 	  THEN '312400'                                                                   	" \
				"			 WHEN (  T.DEAL_TYPE||T.DEAL_CLSS = '01000' /* 예금인출 */						      	" \
				"			 	  OR T.DEAL_TYPE||T.DEAL_CLSS = '01300' /* 현금서비스 */ )					      	" \
				"			 	  THEN                                                                            	" \
				"				  	   CASE WHEN T.DEAL_TIME_TYPE = '1' /* 예금인출-시간내 */             	      	" \
				"					   			 THEN '012200'                                                    	" \
				"							WHEN T.DEAL_TIME_TYPE = '2' /* 예금인출-시간외 */                     	" \
				"								 THEN '012300'                                                    	" \
				"							ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO						      	" \
				"						END                                                                       	" \
				"			 /* 수취조회 */                                                                       	" \
				"			 WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31002'                                              	" \
				"			 	  THEN                                                                            	" \
				"				  	  /* 수취조회-자행이체 */                                                     	" \
				"					  CASE WHEN (T.TRANS_ORG_CD = '0011' OR T.TRANS_ORG_CD = '0012')                " \
				"					  	   		THEN                                                              	" \
				"							   	    /* 수취조회 - 자행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '312490'                                        	" \
				"									 	 /* 수취조회 - 자행이체 - 시간외 */                       	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '312590'                                        	" \
				"									ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                     	" \
				"									END                                                           	" \
				"							ELSE                                                                  	" \
				"								    /* 수취조회 - 타행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '312491'                                        	" \
				"									 	 /* 수취조회 - 타행이체 - 시간외 */                       	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '312591'                                        	" \
				"									ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                     	" \
				"									END                                                           	" \
				"						END                                                                       	" \
				"			/* 계죄이체 */                                                                        	" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '40000'                                               	" \
				"				 THEN                                                                             	" \
				"				 	 /* 계좌이체 - 자행 */                                                        	" \
				"					 CASE WHEN (T.TRANS_ORG_CD = '0011' OR T.TRANS_ORG_CD = '0012')                 " \
				"					  	   		THEN                                                              	" \
				"							   	    /* 계좌이체 - 자행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '012290'                                        	" \
				"									 	 /* 계좌이체 - 자행이체 - 시간외 */                       	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '012390'                                        	" \
				"										 ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                	" \
				"									END                                                           	" \
				"							ELSE                                                                  	" \
				"								    /* 계좌이체 - 타행이체 - 시간내 */                            	" \
				"									CASE WHEN T.DEAL_TIME_TYPE = '1'                              	" \
				"											 THEN '012291'                                        	" \
				"									 	 /* 계좌이체  - 타행이체 - 시간외 */                      	" \
				"										 WHEN T.DEAL_TIME_TYPE = '2'                              	" \
				"											 THEN '012391'                                        	" \
				"										 ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                	" \
				"									END																" \
				"						END                                                                       	" \
				"			/* 통장정리조회 */                                                                     	" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31003'													" \
                "				THEN '312440'																		" \
				"			/* 통장정리 */																			" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '31004'													" \
                "				THEN '012240'																		" \
				"			/* 공과금납부조회 */																	" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '30001'													" \
               	"				THEN																				" \
               	"				/* MS 거래 */																		" \
               	"				CASE WHEN T.TRACK_NO = '3'															" \
               	"						THEN '312470'																" \
               	"					 /* IC 거래 */																	" \
               	"					WHEN T.TRACK_NO = '4'															" \
               	"						 THEN '312460'																" \
               	"					ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO										" \
				"				END																					" \
				"			/* 공과금납부 */																		" \
				"			WHEN T.DEAL_TYPE||T.DEAL_CLSS = '50001'													" \
				"				THEN																				" \
                "				/* MS 거래 */																		" \
                "				CASE WHEN T.TRACK_NO = '3'															" \
                "						THEN '012270'																" \
                "					/* IC 거래 */																	" \
                "					WHEN T.TRACK_NO = '4'															" \
                "						THEN '012260'																" \
                "					ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO										" \
				"				END                         														" \
				"			/* 해외거래 지급일경우 국내 지급(시간내)와 같이 취급 2012.06.15 농협요청 */				" \
				"			WHEN (  T.DEAL_TYPE||T.DEAL_CLSS = '01110' /* 해외예금지급 */							" \
				"				 OR T.DEAL_TYPE||T.DEAL_CLSS = '01010' /* 해외당좌지급 */							" \
				"				 OR T.DEAL_TYPE||T.DEAL_CLSS = '01310' /* 해외현금서비스 */							" \
				"				 )																					" \
				"				THEN '012200'																		" \
				"			ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO												" \
				"		END AS TRADE_TYPE,                                              							" \
				"		CASE WHEN T.DEAL_STATUS = '0'                                   							" \
				"				THEN	 '0210'																		" \
				"			WHEN T.DEAL_STATUS = '1' 																" \
				"				THEN '0430'                                            								" \
				"			WHEN T.DEAL_STATUS = '2'                      											" \
				"			 	THEN																				" \
				"			 		CASE WHEN T.DEAL_TYPE = '0'														" \
				"				 	     	THEN                                                    				" \
				"								CASE WHEN T.ORG_RESPONSE_CD = '11'									" \
				"										THEN '0430'													" \
				"								ELSE '0200'															" \
				"								END																	" \
				"				    	 WHEN (T.DEAL_TYPE = '3' OR T.DEAL_TYPE = '4' OR T.DEAL_TYPE = '5')			" \
				"				            THEN																	" \
				"				            	'0200'																" \
				"					END																				" \
				"			 WHEN T.DEAL_STATUS = '3'																" \
				"			 	  THEN																				" \
				"			 	       CASE WHEN T.DEAL_TYPE = '0'													" \
				"			 	             THEN																	" \
				"     								CASE WHEN T.REFUSE_CD = '608'									" \
				"     								 		THEN '0430'												" \
				"     									   ELSE														" \
				"    									   	    CASE WHEN T.ORG_RESPONSE_CD <> '11'					" \
				"     								  	   			 	  THEN '0210'								" \
				"     								  	   			 ELSE '0200'									" \
				"     											END													" \
				"     								  END															" \
				"         					WHEN (T.DEAL_TYPE = '3' OR T.DEAL_TYPE = '4' OR T.DEAL_TYPE = '5')		" \
				"      						      THEN																" \
				"      						          '0210'														" \
				"      		           		END																		" \
				"		END AS LAST_TYPE,																			" \
				"       CASE WHEN T.ORG_CD <> '011' AND T.ORG_CD <> '012'											" \
				"            THEN DECODE( T.DEAL_STATUS, '0', '00', RPAD(RTRIM(T.ORG_RESPONSE_CD), 2, '9'))			" \
				"            ELSE RPAD(RTRIM(T.ORG_RESPONSE_CD), 2, '9')											" \
				"       END AS ORG_RESPONSE_CD,																		" \
				"		CASE WHEN (ASCII(SUBSTR(T.ORG_CD, 2, 1)) >= 48 AND 											" \
				"						ASCII(SUBSTR(T.ORG_CD, 2, 1)) <= 57)                                      	" \
				"			 	  AND (ASCII(SUBSTR(T.ORG_CD, 3, 1)) >= 48 AND                                    	" \
				"			 	  		ASCII(SUBSTR(T.ORG_CD, 3, 1)) <= 57)                                      	" \
				"				  THEN SUBSTR(T.ORG_CD, 1, 3)                                                       " \
				"			 ELSE '096'                                       										" \
				"		END AS ORG_CD,                                                                            	" \
				"		FC_FN_SECURITY(T.INST_JIJUM_CD, '2') || 					                              	" \
				"			FC_FN_SECURITY(T.ACCOUNT_NO, '2') AS ACCOUNT_NO, 	                                  	" \
				"		LPAD(T.DEAL_AMT, 12, '0') AS DEAL_AMT,                                                    	" \
				"		CASE WHEN /*T.DEAL_TYPE = '0' OR T.DEAL_TYPE = '4'*/										" \
				"				  T.DEAL_TYPE = '0'	AND T.ORG_CD <> '011' 											" \
				"			      AND T.ORG_CD <> '012'	AND T.DEAL_STATUS = '0'										" \
				"			 THEN LPAD( '810', 5, '0')																" \
				"			 WHEN T.DEAL_TYPE <> '3'																" \
				"			 THEN LPAD(DECODE(T.DEAL_STATUS, '0', T.CUST_FEE + T.BANK_FEE, 0), 5, '0')       		" \
				"			 ELSE LPAD('0', 5, '0')                                                               	" \
				"		END AS FEE,                                                                               	" \
				"		SUBSTR(NVL(T.TRANS_ORG_CD, '0000'), 2, 3),                                                	" \
				"		FC_FN_SECURITY(T.TRANS_JIJUM_CD, '2') || 					                              	" \
				"			FC_FN_SECURITY(T.TRANS_ACCOUNT_NO, '2') AS TRANS_ACCOUNT_NO,                          	" \
				"		CASE WHEN C.MAC_MODEL = '1300'																" \
				"			 	  THEN '01'																			" \
				"			 ELSE																					" \
				"			 	  '02'																				" \
				"		END AS ATM_TYPE                                                                             " \
				"FROM	T_FN_NICE_TRAN T,                                                                         	" \
				"		T_CT_NICE_MAC  M,                                                                          	" \
				"		T_CM_MAC	   C																			" \
				"WHERE	T.MAC_NO = M.MAC_NO				                                                          	" \
				"AND    T.DEAL_DATE = '%s'                                                                       	" \
				"AND	T.ADMIS_ORG = 'B' 																			" \
				"AND	M.JOIN_CD IN ('011', '012') /*MS삭제*/											      		" \
				"AND	C.MAC_NO = T.MAC_NO																			" \
				"AND	C.JIJUM_CD = '9600'																			" \
				"AND    C.ORG_CD = '096'																				",
				szDate);

		EXEC SQL PREPARE SNH1 FROM :hSQLmain;
		EXEC SQL DECLARE CNH1 CURSOR FOR SNH1;
		EXEC SQL OPEN CNH1;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetNongHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetNongHTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		while (1)
		{
			EXEC SQL	FETCH	CNH1	INTO 	hDealDate,
											hDealTime,
											hDealNo,
											hJoinMojum,
											hJoinCd,
											hMacNo,
											hTradeType,
											hLastType,
											hOrgRespCd,
											hOrgCd,
											hAccountNo,
											hDealAmt,
											hFee,
											hTransOrgCd,
											hTransAccountNo,
											hAtmType;
			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CNH1;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "VC003322%07ld", ncount+1 );
			fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
					8, hDealDate,	6, hDealTime, 13, hDealNo,
					6, hJoinMojum, 3, hJoinCd, 4, hMacNo, 6, hTradeType,
					4, hLastType, 2, hOrgRespCd, 3, hOrgCd, 17, hAccountNo,
					12, hDealAmt, 5, hFee, 3, hTransOrgCd, 14, hTransAccountNo,
					2, hAtmType, 47, " ");

			lnTotalAmt = lnTotalAmt + atol(hDealAmt);

			ncount++;
	    }
		EXEC SQL CLOSE CNH1;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetNongHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}
	fprintf( pfTran, "VC0033339999999011NC %07ld%.8s%*s\n", ncount, hPreDate, 134, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+3+3, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}


/* 농협 */
int GetNongHMacData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hMacNo[4+1];
	char	hType[3+1];
	char	hSetPlace[30+1];
	char	hSetAddr[100+1];
	char	hInterphoneNo[15+1];
	char	hZipNo[6+1];
	char	hJoinMojumCd[6+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];
	char	hActDate[8+1];

	FILE	*pfTran;

	memset( hType        	, 0x00	, sizeof( hType         ) );
	memset( hMacNo        , 0x00	, sizeof( hMacNo         ) );
	memset( hSetPlace     , 0x00	, sizeof( hSetPlace      ) );
	memset( hSetAddr      , 0x00	, sizeof( hSetAddr       ) );
	memset( hInterphoneNo , 0x00	, sizeof( hInterphoneNo  ) );
	memset( hZipNo        , 0x00	, sizeof( hZipNo         ) );
	memset( hJoinMojumCd  , 0x00	, sizeof( hJoinMojumCd   ) );

	memset( hActDate , 0x00	, sizeof( hActDate   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

/* 임시.. 전송일 10일 거래일 6,7,8,9일 데이터 요청
memcpy( hActDate, "20061006", 8 );
*/

	/* 매월 첫일이 휴일면 익영업일을.. 그렇지 않으면 전송일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
                                                        std_date,
                                                    pkg_fn_common.sf_getPostActDate(std_date)),
                                                    pkg_fn_common.sf_getPostActDate(std_date))
             INTO	hActDate
             FROM     T_FN_CALENDAR
             WHERE     std_date = substr( :pTransDate, 1, 6) || '01';

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 익영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 익영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	if( memcmp(pTransDate, hActDate, 8 ) != 0  )
	{
		logger(">>> [GetNongHTranData][%s]-[%s] 휴일 전송 하지 않음, 매달 첫 영업일에만 전송 \n", pTransDate, hActDate);
		return -2;
	}


 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetNongHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	ncount = 0;

	fprintf( pfTran, "VC0002110000000011NC 0000000%8s%*s\n", pTransDate, 164, " " );

	/* 브랜드 제휴가 아닌 일반 CD VAN 일 경우 '096'->'NCJ'로 변경
		NCJ 와 별개로 브랜드 제휴가 아닌 기기를 '096'으로 아래 추가 20120703 BY 이재원 */
	sprintf(hSQLmain,
			"SELECT  DECODE(NMAC.JOIN_CD, '0MS', 'NCB', '011', 'NCI', '012', 'NCI', 'NCJ'),		" \
			"		 MAC.MAC_NO,                                                 				" \
			"        SUBSTR(SITE.SITE_NM, 1, 13),                                				" \
			"        SUBSTR(SITE.SET_ADDR, 1, 48),                                 				" \
			"        '0800228252',                                         						" \
			"        SITE.ZIP_NO,                                                				" \
			"        LPAD(NVL(NMAC.JOIN_MOJUM_CD, '0'), 6 , '0') AS JOIN_MOJUM_CD				" \
			"FROM    T_CM_MAC        MAC,                                        				" \
			"        T_CM_SITE       SITE,                                       				" \
			"        T_CT_NICE_MAC   NMAC                                        				" \
			"WHERE   MAC.ORG_CD = '096'                                           				" \
			"AND     MAC.JIJUM_CD = '9600'                                       				" \
			"AND     MAC.ORG_CD = SITE.ORG_CD                                    				" \
			"AND     MAC.JIJUM_CD = SITE.JIJUM_CD                                				" \
			"AND     MAC.SITE_CD = SITE.SITE_CD                                  				" \
			"AND     MAC.MAC_NO = NMAC.MAC_NO                                    				" \
			"/*AND     NMAC.JOIN_CD IN ('011', '012', '0MS')                       */ 			" \
			"AND     MAC.OPEN_DATE <= '%s'                                 						" \
			"AND     ( MAC.CLOSE_DATE IS NULL OR MAC.CLOSE_DATE >= '%s' )  						" \
			"UNION ALL																			" \
			"SELECT  '096' AS ORG_CD_AAA,														" \
			"		 MAC.MAC_NO,                                                 				" \
			"        SUBSTR(SITE.SITE_NM, 1, 13),                                				" \
			"        SUBSTR(SITE.SET_ADDR, 1, 48),                                 				" \
			"        '0800228252',                                         						" \
			"        SITE.ZIP_NO,                                                				" \
			"        LPAD(NVL(NMAC.JOIN_MOJUM_CD, '0'), 6 , '0') AS JOIN_MOJUM_CD				" \
			"FROM    T_CM_MAC        MAC,                                        				" \
			"        T_CM_SITE       SITE,                                       				" \
			"        T_CT_NICE_MAC   NMAC                                        				" \
			"WHERE   MAC.ORG_CD = '096'                                           				" \
			"AND     MAC.JIJUM_CD = '9600'                                       				" \
			"AND     MAC.ORG_CD = SITE.ORG_CD                                    				" \
			"AND     MAC.JIJUM_CD = SITE.JIJUM_CD                                				" \
			"AND     MAC.SITE_CD = SITE.SITE_CD                                  				" \
			"AND     MAC.MAC_NO = NMAC.MAC_NO                                    				" \
			"AND     NVL(NMAC.JOIN_CD, '0') NOT IN ('011', '012', '0MS')                        " \
			"AND     MAC.OPEN_DATE <= '%s'                                 						" \
			"AND     ( MAC.CLOSE_DATE IS NULL OR MAC.CLOSE_DATE >= '%s' )                       " ,
			pTransDate, pTransDate,pTransDate, pTransDate);

	EXEC SQL PREPARE SNH2 FROM :hSQLmain;
	EXEC SQL DECLARE CNH2 CURSOR FOR SNH2;
	EXEC SQL OPEN CNH2;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetNongHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetNongHTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}


	while (1)
	{
		EXEC SQL	FETCH	CNH2	INTO 	hType,
											hMacNo,
											hSetPlace,
											hSetAddr,
											hInterphoneNo,
											hZipNo,
											hJoinMojumCd;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CNH2;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "VC000222%07ldI", ncount+1 );
		fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
				3, hType, 4, hMacNo,	30, hSetPlace, 100, hSetAddr,
				15, hInterphoneNo, 6, hZipNo, 6, hJoinMojumCd, 20, " ");

		ncount++;
    }
	EXEC SQL CLOSE CNH2;

	fprintf( pfTran, "VC0002339999999011NC %07ld%.8s%*s\n", ncount, pTransDate, 164, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+3+3, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}


/* 농협 브랜드제휴 기기정보(마사회제외) */
int GetNongHBrandMacData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hMacNo[4+1];
	char	hMacModel[1+1];
	char	hOpenDate[8+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];
	char	hActDate[8+1];
	char	hPreActDate[8+1];
	char	hPreActYM[6+1];

	FILE	*pfTran;

	memset( hMacNo        , 0x00	, sizeof( hMacNo         ) );
	memset( hMacModel     , 0x00	, sizeof( hMacModel      ) );
	memset( hOpenDate      , 0x00	, sizeof( hOpenDate       ) );

	memset( hActDate , 0x00	, sizeof( hActDate   ) );
	memset( hPreActYM , 0x00	, sizeof( hPreActYM   ) );
	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

/* 임시.. 전송일 10일 거래일 6,7,8,9일 데이터 요청
memcpy( hActDate, "20061006", 8 );
*/

	/* 매월 첫일이 휴일면 익영업일을.. 그렇지 않으면 전송일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
                                                        std_date,
                                                    pkg_fn_common.sf_getPostActDate(std_date)),
                                                    pkg_fn_common.sf_getPostActDate(std_date))
             INTO	hActDate
             FROM     T_FN_CALENDAR
             WHERE     std_date = substr( :pTransDate, 1, 6) || '01';

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 익영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 익영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	if( memcmp(pTransDate, hActDate, 8 ) != 0  )
	{
		logger(">>> [GetNongHTranData][%s]-[%s] 휴일 전송 하지 않음, 매달 첫 영업일에만 전송 \n", pTransDate, hActDate);
		return -2;
	}

	EXEC SQL SELECT pkg_fn_common.sf_getPreActDate(std_date)
		     INTO 	hPreActDate
             FROM   T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	memcpy( hPreActYM, hPreActDate, 6 );


 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetNongHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	ncount = 0;

	fprintf( pfTran, "VC000111NCI*******%6s%*s\n", hPreActYM, 26, " " );

	sprintf(hSQLmain,
			"SELECT  MAC.MAC_NO,                                                 	" \
			"        DECODE(CO1.CD_NM5, 'CD', '1', 'CDP', '2', '3' ),				" \
			"        MAC.OPEN_DATE													" \
			"FROM    T_CM_MAC        MAC,                                        	" \
			"        T_CM_SITE       SITE,                                       	" \
			"        T_CT_NICE_MAC   NMAC,                                        	" \
			"		 T_CM_COMMON	 CO1											" \
			"WHERE   MAC.ORG_CD = '096'                                           	" \
			"AND     MAC.JIJUM_CD = '9600'                                       	" \
			"AND     MAC.ORG_CD = SITE.ORG_CD                                    	" \
			"AND     MAC.JIJUM_CD = SITE.JIJUM_CD                                	" \
			"AND     MAC.SITE_CD = SITE.SITE_CD                                  	" \
			"AND	 CO1.LARGE_CD = '2110'											" \
			"AND	 CO1.SMALL_CD = MAC.MAC_MODEL									" \
			"AND     MAC.MAC_NO = NMAC.MAC_NO                                    	" \
			"AND     NMAC.JOIN_CD IN ('011', '012')			                        " \
			"AND     MAC.OPEN_DATE <= '%s'                                 			" \
			"AND     ( MAC.CLOSE_DATE IS NULL OR MAC.CLOSE_DATE >= '%s' )  			",
			hPreActDate, hPreActDate);

	EXEC SQL PREPARE SNH3 FROM :hSQLmain;
	EXEC SQL DECLARE CNH3 CURSOR FOR SNH3;
	EXEC SQL OPEN CNH3;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetNongHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetNongHTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}


	while (1)
	{
		EXEC SQL	FETCH	CNH3	INTO 	hMacNo,
											hMacModel,
											hOpenDate;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CNH3;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "VC111122%07ld%06sNCI", ncount+1, hPreActYM );
		fprintf( pfTran, "%.*s%.*s%.*s1000000000000\n",
				4, hMacNo,	1, hMacModel, 8, hOpenDate);

		ncount++;
    }
	EXEC SQL CLOSE CNH3;

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+3, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}


/* 은행 공통 - 대구, 우리, 제일, 농협중앙회, 농협단위조합, 하나(공동망), 외환카드 */
int GetCommonTranData(char *pTransDate, char *pOrgCd, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hWorkType[6+1];
	char	hDataType[2+1];
	char	hDealDate[10+1];
	char	hAtmDealNo[16+1];
	char	hInsetOrgCd[4+1];
	char	hInsetJijumCd[4+1];
	char	hAccountNo[25+1];

	char	hDealAmt[12+1];
	char	hCustFee[6+1];
	char	hBankFee[6+1];
	char	hOrgRespCd[2+1];
	char	hDealNo[12+1];
	char	hDealStatus[1+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];
	char	hTradeType[2+1];

	char	hFirstDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	int		nDataCnt;
	char	szContent[1024];
	char	szDate[8+1];
	char	szOrgCd[3+1];
	char	szCnt[10];

	int		nTotAcptCnt;
	long	lnTotAcptAmt;
	long	lnTotCustAmt;
	long	lnTotBankAmt;
	int		nTotCancelCnt;
	long	lnTotCancelAmt;
	int		nTotNotMngCnt;
	long	lnTotNotMngAmg;
	int		nTotRejCnt;
	long	lnTotRejAmt;

	FILE	*pfTran;

	memset( hWorkType		, 0x00, sizeof( hWorkType     ) );
	memset( hDataType       , 0x00, sizeof( hDataType     ) );
	memset( hDealDate       , 0x00, sizeof( hDealDate     ) );
	memset( hAtmDealNo      , 0x00, sizeof( hAtmDealNo    ) );
	memset( hInsetOrgCd     , 0x00, sizeof( hInsetOrgCd   ) );
	memset( hInsetJijumCd   , 0x00, sizeof( hInsetJijumCd ) );
	memset( hAccountNo      , 0x00, sizeof( hAccountNo    ) );
	memset( hDealAmt        , 0x00, sizeof( hDealAmt      ) );
	memset( hCustFee        , 0x00, sizeof( hCustFee      ) );
	memset( hBankFee        , 0x00, sizeof( hBankFee      ) );
	memset( hOrgRespCd      , 0x00, sizeof( hOrgRespCd    ) );
	memset( hDealNo         , 0x00, sizeof( hDealNo       ) );
	memset( hDealStatus     , 0x00, sizeof( hDealStatus   ) );


	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	memset(szOrgCd,		0x00, sizeof(szOrgCd));

	memset( szCnt     	, 0x00, sizeof( szCnt      	 ) );

	memcpy( szOrgCd, &pOrgCd[1], 2 );

	/* 전송일이 휴일이면 전송일을 전송일이 영업일이면 전 영업일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCommonTranData-%s] 전영업일 없음. [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCommonTranData-%s] 전영업일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetCommonTranData-%s] 휴일 전송 안함 [%s]\n", szOrgCd,  pTransDate);
		return -2;
	}

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCommonTranData-%s] 전일 없음. [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCommonTranData-%s] 전일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCommonTranData-%s] FileOpenError [%s]\n", pOrgCd, pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;


	/* 전체 Header */
	fprintf( pfTran, "ATM001110000000%2s030000000%.*s%*s\n", szOrgCd, 6, &pTransDate[2], 138, " " );

	while(1)
	{
		/* 영업내 Data부 Header */
		fprintf( pfTran, "ATM00122%07ld%02s03 012200110096%04s%06s%06s%06s%*s\n",
					ncount + 1, szOrgCd, szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );

		/* Header 와 Trailer도 count에 포함 */
		ncount++;

		/* 시간내 데이터부 */
		/* 하나은행 공동망 일 경우  net_org_cd <> '81' 추가 */
		if( strncmp( pOrgCd, "081", 3) == 0 )
		{
			strcpy(hSQLsub,	"AND	net_org_cd <> '081' ");
		}


		sprintf(hSQLmain,
				"SELECT	DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ) AS WORK_TYPE,		" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				"		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                 	" \
				"		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                            	" \
				"		RPAD(DEAL_NO, 12, ' '),                                         	" \
				"		DEAL_STATUS                                                     	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE = '0'                                                 	" \
				"AND	DEAL_TIME_TYPE = '1'												" \
				"AND	ADMIS_ORG = 'B' 													" \
				"AND	ORG_CD = '0'||'%s'													" \
				"%s																			" ,
				szDate, szOrgCd, hSQLsub);

		EXEC SQL PREPARE SLG1 FROM :hSQLmain;
		EXEC SQL DECLARE CLG1 CURSOR FOR SLG1;
		EXEC SQL OPEN CLG1;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCommonTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetCommonTranData-%s] Error Query String [%s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}

		nDataCnt = 0;
		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CLG1 INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CLG1;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			if( strncmp( pOrgCd, "020", 3) == 0 )
			{
				memset(&hAccountNo[7], '*', strlen(hAccountNo)-7);
			}

			fprintf( pfTran, "ATM00122%07ld%02s03 %s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%*s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									ncount+1,
									szOrgCd,
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									1	, 	" ");

			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CLG1;

		/* 영업내 Data부 Trailer */
		fprintf( pfTran, "ATM00122%07ld%02s03 01220033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						ncount+1,
						szOrgCd			,
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );
		ncount++;

		/* 영업외 Data부 Header */
		fprintf( pfTran, "ATM00122%07ld%02s03 012300110096%04s%06s%06s%06s%*s\n",
							ncount + 1, szOrgCd, szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );
		ncount++;

		/* 시간외 데이터부 */
		/* 하나은행 공동망 일 경우  net_org_cd <> '81' 추가 */
		if( strncmp( pOrgCd, "081", 3) == 0 )
		{
			strcpy(hSQLsub,	"AND	net_org_cd <> '081' ");
		}
		sprintf(hSQLmain,
				"SELECT	DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ) AS WORK_TYPE,		" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				"		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                 	" \
				"		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                            	" \
				"		RPAD(DEAL_NO, 12, ' '),                                         	" \
				"		DEAL_STATUS                                                     	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE = '0'                                                 	" \
				"AND	DEAL_TIME_TYPE = '2'												" \
				"AND	ADMIS_ORG = 'B' 													" \
				"AND	ORG_CD = '0'||'%s'													" \
				"%s																			" ,
				szDate, szOrgCd, hSQLsub);

		EXEC SQL PREPARE SLG2 FROM :hSQLmain;
		EXEC SQL DECLARE CLG2 CURSOR FOR SLG2;
		EXEC SQL OPEN CLG2;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCommonTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetCommonTranData-%s] Error Query String [%.1024s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		nDataCnt = 0;

		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CLG2 INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CLG2;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			if( strncmp( pOrgCd, "020", 3) == 0 )
			{
				memset(&hAccountNo[7], '*', strlen(hAccountNo)-7);
			}

			fprintf( pfTran, "ATM00122%07ld%02s03 %s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%*s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									ncount+1,
									szOrgCd,
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									1	, 	" ");
			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CLG2;

		/* 영업외 Data부 Trailer */
		fprintf( pfTran, "ATM00122%07ld%02s03 01230033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						ncount+1,
						szOrgCd			,
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );

		ncount++;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetCommonTranData-%s] 전일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}

	fprintf( pfTran, "ATM001339999999%2s03%07ld%*s\n", szOrgCd, ncount, 144, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+2+2, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}

int GetKiupTranData(char *pTransDate, char *pOrgCd, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hWorkType[6+1];
	char	hDataType[2+1];
	char	hDealDate[10+1];
	char	hAtmDealNo[16+1];
	char	hInsetOrgCd[4+1];
	char	hInsetJijumCd[4+1];
	char	hAccountNo[25+1];

	char	hDealAmt[12+1];
	char	hCustFee[6+1];
	char	hBankFee[6+1];
	char	hOrgRespCd[2+1];
	char	hDealNo[12+1];
	char	hDealStatus[1+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];
	char	hTradeType[2+1];

	char	hFirstDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	int		nDataCnt;
	char	szContent[1024];
	char	szDate[8+1];
	char	szOrgCd[3+1];
	char	szCnt[10];

	int		nTotAcptCnt;
	long	lnTotAcptAmt;
	long	lnTotCustAmt;
	long	lnTotBankAmt;
	int		nTotCancelCnt;
	long	lnTotCancelAmt;
	int		nTotNotMngCnt;
	long	lnTotNotMngAmg;
	int		nTotRejCnt;
	long	lnTotRejAmt;

	FILE	*pfTran;

	memset( hWorkType		, 0x00, sizeof( hWorkType     ) );
	memset( hDataType       , 0x00, sizeof( hDataType     ) );
	memset( hDealDate       , 0x00, sizeof( hDealDate     ) );
	memset( hAtmDealNo      , 0x00, sizeof( hAtmDealNo    ) );
	memset( hInsetOrgCd     , 0x00, sizeof( hInsetOrgCd   ) );
	memset( hInsetJijumCd   , 0x00, sizeof( hInsetJijumCd ) );
	memset( hAccountNo      , 0x00, sizeof( hAccountNo    ) );
	memset( hDealAmt        , 0x00, sizeof( hDealAmt      ) );
	memset( hCustFee        , 0x00, sizeof( hCustFee      ) );
	memset( hBankFee        , 0x00, sizeof( hBankFee      ) );
	memset( hOrgRespCd      , 0x00, sizeof( hOrgRespCd    ) );
	memset( hDealNo         , 0x00, sizeof( hDealNo       ) );
	memset( hDealStatus     , 0x00, sizeof( hDealStatus   ) );


	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	memset(szOrgCd,		0x00, sizeof(szOrgCd));

	memset( szCnt     	, 0x00, sizeof( szCnt      	 ) );

	memcpy( szOrgCd, &pOrgCd[1], 2 );


	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;


memcpy(hPreActDate, hPreDate, 8);

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCommonTranData-%s] 전일 없음. [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCommonTranData-%s] 전일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCommonTranData-%s] FileOpenError [%s]\n", pOrgCd, pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;


	/* 전체 Header */
	fprintf( pfTran, "ATM001110000000%2s030000000%.*s%*s\n", szOrgCd, 6, &pTransDate[2], 138, " " );


		/* 영업내 Data부 Header */
		fprintf( pfTran, "ATM00122%07ld%02s03 012200110096%04s%06s%06s%06s%*s\n",
					ncount + 1, szOrgCd, szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );

		/* Header 와 Trailer도 count에 포함 */
		ncount++;

		/* 시간내 데이터부 */
		/* 하나은행 공동망 일 경우  net_org_cd <> '81' 추가 */
		if( strncmp( pOrgCd, "081", 3) == 0 )
		{
			strcpy(hSQLsub,	"AND	net_org_cd <> '081' ");
		}

logger( "szDate[%s], szOrgCd[%s], hSQLsub[%s]\n", szDate, szOrgCd, hSQLsub);

		sprintf(hSQLmain,
				"SELECT	DECODE( DEAL_TYPE, '0', DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ), "\
				"						       '500000' ) AS WORK_TYPE,						" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				"		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                		" \
				"		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                               " \
				"		RPAD(DEAL_NO, 12, ' '),                                         	" \
				"		DEAL_STATUS                                                     	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE IN ('0', '1')                                            	" \
				"AND	DEAL_TIME_TYPE = '1'												" \
				"/*AND	ADMIS_ORG = 'B' 20091103이재원과장 요청 삭제*/						" \
				"AND	ORG_CD = '0'||'%s'													" \
				"%s																			" ,
				szDate, szOrgCd, hSQLsub);

		EXEC SQL PREPARE SKU FROM :hSQLmain;
		EXEC SQL DECLARE CKU CURSOR FOR SKU;
		EXEC SQL OPEN CKU;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCommonTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetCommonTranData-%s] Error Query String [%s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}

		nDataCnt = 0;
		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CKU INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CKU;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "ATM00122%07ld%02s03 %s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%*s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									ncount+1,
									szOrgCd,
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									1	, 	" ");

			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CKU;

		/* 영업내 Data부 Trailer */
		fprintf( pfTran, "ATM00122%07ld%02s03 01220033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						ncount+1,
						szOrgCd			,
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );
		ncount++;

		/* 영업외 Data부 Header */
		fprintf( pfTran, "ATM00122%07ld%02s03 012300110096%04s%06s%06s%06s%*s\n",
							ncount + 1, szOrgCd, szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );
		ncount++;

		/* 시간외 데이터부 */
		/* 하나은행 공동망 일 경우  net_org_cd <> '81' 추가 */
		if( strncmp( pOrgCd, "081", 3) == 0 )
		{
			strcpy(hSQLsub,	"AND	net_org_cd <> '081' ");
		}
		sprintf(hSQLmain,
				"SELECT	DECODE( DEAL_TYPE, '0', DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ), "\
				"						       '500000' ) AS WORK_TYPE,						" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				" 		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                		" \
				" 		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                            	" \
				" 		RPAD(DEAL_NO, 12, ' '),                                         	" \
				" 		DEAL_STATUS                                                     	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE IN ('0', '1')                                            	" \
				"AND	DEAL_TIME_TYPE = '2'												" \
				"/*AND	ADMIS_ORG = 'B' 20091103이재원과장 요청 삭제*/						" \
				"AND	ORG_CD = '0'||'%s'													" \
				"%s																			" ,
				szDate, szOrgCd, hSQLsub);

		EXEC SQL PREPARE SKU2 FROM :hSQLmain;
		EXEC SQL DECLARE CKU2 CURSOR FOR SKU2;
		EXEC SQL OPEN CKU2;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCommonTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetCommonTranData-%s] Error Query String [%.1024s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		nDataCnt = 0;

		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CKU2 INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CKU2;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "ATM00122%07ld%02s03 %s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%*s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									ncount+1,
									szOrgCd,
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									1	, 	" ");

			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CKU2;

		/* 영업외 Data부 Trailer */
		fprintf( pfTran, "ATM00122%07ld%02s03 01230033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						ncount+1,
						szOrgCd			,
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );

		ncount++;




	fprintf( pfTran, "ATM001339999999%2s03%07ld%*s\n", szOrgCd, ncount, 144, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+2+2, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}


int GetKBSTTranData(char *pTransDate, char *pOrgCd, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hWorkType[6+1];
	char	hDataType[2+1];
	char	hDealDate[10+1];
	char	hAtmDealNo[16+1];
	char	hInsetOrgCd[4+1];
	char	hInsetJijumCd[4+1];
	char	hAccountNo[25+1];

	char	hDealAmt[12+1];
	char	hCustFee[6+1];
	char	hBankFee[6+1];
	char	hOrgRespCd[2+1];
	char	hDealNo[13+1];
	char	hDealStatus[1+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];
	char	hTradeType[2+1];

	char	hFirstDate[8+1];
	char	hSpace[1+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
	char	hSQLsub1[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	int		nDataCnt;
	char	szContent[1024];
	char	szDate[8+1];
	char	szOrgCd[3+1];
	char	szCnt[10];

	int		nTotAcptCnt;
	long	lnTotAcptAmt;
	long	lnTotCustAmt;
	long	lnTotBankAmt;
	int		nTotCancelCnt;
	long	lnTotCancelAmt;
	int		nTotNotMngCnt;
	long	lnTotNotMngAmg;
	int		nTotRejCnt;
	long	lnTotRejAmt;

	FILE	*pfTran;

	memset( hWorkType		, 0x00, sizeof( hWorkType     ) );
	memset( hDataType       , 0x00, sizeof( hDataType     ) );
	memset( hDealDate       , 0x00, sizeof( hDealDate     ) );
	memset( hAtmDealNo      , 0x00, sizeof( hAtmDealNo    ) );
	memset( hInsetOrgCd     , 0x00, sizeof( hInsetOrgCd   ) );
	memset( hInsetJijumCd   , 0x00, sizeof( hInsetJijumCd ) );
	memset( hAccountNo      , 0x00, sizeof( hAccountNo    ) );
	memset( hDealAmt        , 0x00, sizeof( hDealAmt      ) );
	memset( hCustFee        , 0x00, sizeof( hCustFee      ) );
	memset( hBankFee        , 0x00, sizeof( hBankFee      ) );
	memset( hOrgRespCd      , 0x00, sizeof( hOrgRespCd    ) );
	memset( hDealNo         , 0x00, sizeof( hDealNo       ) );
	memset( hDealStatus     , 0x00, sizeof( hDealStatus   ) );


	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );
	memset( hSpace		, 0x00	, sizeof(hSpace) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));
	memset(hSQLsub1,	0x00, sizeof(hSQLsub1));

	memset(szOrgCd,		0x00, sizeof(szOrgCd));

	memset( szCnt     	, 0x00, sizeof( szCnt      	 ) );

	memcpy( szOrgCd, &pOrgCd[1], 2 );


	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;


memcpy(hPreActDate, hPreDate, 8);

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetKBSTTranData-%s] 전일 없음. [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetKBSTTranData-%s] 전일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetKBSTTranData-%s] FileOpenError [%s]\n", pOrgCd, pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;


	/* 전체 Header */
	fprintf( pfTran, "ATM001110000000%2s030000000%.*s%*s\n", szOrgCd, 6, &pTransDate[2], 138, " " );


		/* 영업내 Data부 Header */
		fprintf( pfTran, "ATM00122%07ld%02s03 012200110096%04s%06s%06s%06s%*s\n",
					ncount + 1, szOrgCd, szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );

		/* Header 와 Trailer도 count에 포함 */
		ncount++;

		/* 시간내 데이터부 */

		/* 국민은행 일 경우 추가 */
		if( strncmp( pOrgCd, "004", 3) == 0 )
		{
			strcpy(hSQLsub1, "		LPAD(DEAL_NO, 13, 0),	" \
							 "		DEAL_STATUS,			" \
							 "		'' 						" );
			strcpy(hSQLsub,	"AND	net_org_cd = '099' 		");
		}
		else
		{
			strcpy(hSQLsub1, "		RPAD(DEAL_NO, 12, ' '), " \
							 "		DEAL_STATUS,			" \
							 "		' ' 					" );
		}

		sprintf(hSQLmain,
				"SELECT	DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ) AS WORK_TYPE,		" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				"		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                 	" \
				"		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                               " \
				"		%s																	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE = '0'                                                 	" \
				"AND	DEAL_STATUS = '0'                                                 	" \
				"AND	DEAL_TIME_TYPE = '1'												" \
				"AND	ADMIS_ORG = 'B' 													" \
				"AND	ORG_CD = '0'||'%s'													" \
				" %s																		" ,
				hSQLsub1, szDate, szOrgCd, hSQLsub);

		EXEC SQL PREPARE SKBST FROM :hSQLmain;
		EXEC SQL DECLARE CKBST CURSOR FOR SKBST;
		EXEC SQL OPEN CKBST;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetKBSTTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetKBSTTranData-%s] Error Query String [%s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}

		nDataCnt = 0;
		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CKBST INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ,
											hSpace;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CKBST;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "ATM00122%07ld%02s03 %s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									ncount+1,
									szOrgCd,
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									hSpace);

			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CKBST;

		/* 영업내 Data부 Trailer */
		fprintf( pfTran, "ATM00122%07ld%02s03 01220033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						ncount+1,
						szOrgCd			,
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );
		ncount++;

		/* 영업외 Data부 Header */
		fprintf( pfTran, "ATM00122%07ld%02s03 012300110096%04s%06s%06s%06s%*s\n",
							ncount + 1, szOrgCd, szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );
		ncount++;

		/* 시간외 데이터부 */
		if( strncmp( pOrgCd, "004", 3) == 0 )
		{
			strcpy(hSQLsub1, "		LPAD(DEAL_NO, 13, 0),	" \
							 "		DEAL_STATUS,			" \
							 "		'' 						" );
			strcpy(hSQLsub,	"AND	net_org_cd = '099' 		");
		}
		else
		{
			strcpy(hSQLsub1, "		RPAD(DEAL_NO, 12, ' '), " \
							 "		DEAL_STATUS,			" \
							 "		' ' 					" );
		}

		sprintf(hSQLmain,
				"SELECT	DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ) AS WORK_TYPE,		" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				" 		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                 	" \
				" 		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                            	" \
				" 		%s                                         	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE = '0'                                                 	" \
				"AND	DEAL_STATUS = '0'                                                 	" \
				"AND	DEAL_TIME_TYPE = '2'												" \
				"AND	ADMIS_ORG = 'B' 													" \
				"AND	ORG_CD = '0'||'%s'													" \
				" %s																		" ,
				hSQLsub1, szDate, szOrgCd, hSQLsub);

		EXEC SQL PREPARE SKBST2 FROM :hSQLmain;
		EXEC SQL DECLARE CKBST2 CURSOR FOR SKBST2;
		EXEC SQL OPEN CKBST2;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetKBSTTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetKBSTTranData-%s] Error Query String [%.1024s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		nDataCnt = 0;

		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CKBST2 INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus	  ,
											hSpace   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CKBST2;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "ATM00122%07ld%02s03 %s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									ncount+1,
									szOrgCd,
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									hSpace	);

			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CKBST2;

		/* 영업외 Data부 Trailer */
		fprintf( pfTran, "ATM00122%07ld%02s03 01230033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						ncount+1,
						szOrgCd			,
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );

		ncount++;




	fprintf( pfTran, "ATM001339999999%2s03%07ld%*s\n", szOrgCd, ncount, 144, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+2+2, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}



int GetCommonImsiData(char *pTransDate, char *pOrgCd, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hWorkType[6+1];
	char	hDataType[2+1];
	char	hDealDate[10+1];
	char	hAtmDealNo[16+1];
	char	hInsetOrgCd[4+1];
	char	hInsetJijumCd[4+1];
	char	hAccountNo[25+1];

	char	hDealAmt[12+1];
	char	hCustFee[6+1];
	char	hBankFee[6+1];
	char	hOrgRespCd[2+1];
	char	hDealNo[12+1];
	char	hDealStatus[1+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];
	char	hTradeType[2+1];

	char	hFirstDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	int		nDataCnt;
	char	szContent[1024];
	char	szDate[8+1];
	char	szOrgCd[3+1];
	char	szCnt[10];

	int		nTotAcptCnt;
	long	lnTotAcptAmt;
	long	lnTotCustAmt;
	long	lnTotBankAmt;
	int		nTotCancelCnt;
	long	lnTotCancelAmt;
	int		nTotNotMngCnt;
	long	lnTotNotMngAmg;
	int		nTotRejCnt;
	long	lnTotRejAmt;

	FILE	*pfTran;

	memset( hWorkType		, 0x00, sizeof( hWorkType     ) );
	memset( hDataType       , 0x00, sizeof( hDataType     ) );
	memset( hDealDate       , 0x00, sizeof( hDealDate     ) );
	memset( hAtmDealNo      , 0x00, sizeof( hAtmDealNo    ) );
	memset( hInsetOrgCd     , 0x00, sizeof( hInsetOrgCd   ) );
	memset( hInsetJijumCd   , 0x00, sizeof( hInsetJijumCd ) );
	memset( hAccountNo      , 0x00, sizeof( hAccountNo    ) );
	memset( hDealAmt        , 0x00, sizeof( hDealAmt      ) );
	memset( hCustFee        , 0x00, sizeof( hCustFee      ) );
	memset( hBankFee        , 0x00, sizeof( hBankFee      ) );
	memset( hOrgRespCd      , 0x00, sizeof( hOrgRespCd    ) );
	memset( hDealNo         , 0x00, sizeof( hDealNo       ) );
	memset( hDealStatus     , 0x00, sizeof( hDealStatus   ) );


	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	memset(szOrgCd,		0x00, sizeof(szOrgCd));

	memset( szCnt     	, 0x00, sizeof( szCnt      	 ) );

	memcpy( szOrgCd, &pOrgCd[1], 2 );


	/* 임시.. 전송일 10일 거래일 8,9일 데이터 요청 */
	memcpy( hPreActDate, "20061008", 8 );

	/* 전송일이 휴일이면 전송일을 전송일이 영업일이면 전 영업일을 return */
	/*
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCommonTranData-%s] 전영업일 없음. [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCommonTranData-%s] 전영업일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	*/

	/* 휴일에는 전송하지 않는다. */
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetCommonTranData-%s] 휴일 전송 안함 [%s]\n", szOrgCd,  pTransDate);
		return -2;
	}

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCommonTranData-%s] 전일 없음. [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCommonTranData-%s] 전일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCommonTranData-%s] FileOpenError [%s]\n", pOrgCd, pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;


	/* 전체 Header */
	fprintf( pfTran, "ATM001110000000%2s030000000%.*s%*s\n", szOrgCd, 6, &pTransDate[2], 138, " " );

	while(1)
	{
		/* 영업내 Data부 Header */
		fprintf( pfTran, "ATM00122%07ld%02s03 012200110096%04s%06s%06s%06s%*s\n",
					ncount + 1, szOrgCd, szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );

		/* Header 와 Trailer도 count에 포함 */
		ncount++;

		/* 시간내 데이터부 */
		/* 하나은행 공동망 일 경우  net_org_cd <> '81' 추가 */
		if( strncmp( pOrgCd, "081", 3) == 0 )
		{
			strcpy(hSQLsub,	"AND	net_org_cd <> '081' ");
		}


		sprintf(hSQLmain,
				"SELECT	DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ) AS WORK_TYPE,		" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				"		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                 		" \
				"		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                              	" \
				"		RPAD(DEAL_NO, 12, ' '),                                         	" \
				"		DEAL_STATUS                                                     	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE = '0'                                                 	" \
				"AND	DEAL_TIME_TYPE = '1'												" \
				"AND	ADMIS_ORG = 'B' 													" \
				"AND	ORG_CD = '0'||'%s'													" \
				"%s																			" ,
				szDate, szOrgCd, hSQLsub);

		EXEC SQL PREPARE SIM1 FROM :hSQLmain;
		EXEC SQL DECLARE CIM1 CURSOR FOR SIM1;
		EXEC SQL OPEN CIM1;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCommonTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetCommonTranData-%s] Error Query String [%s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}

		nDataCnt = 0;
		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CIM1 INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CIM1;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "ATM00122%07ld%02s03 %s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%*s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									ncount+1,
									szOrgCd,
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									1	, 	" ");

			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CIM1;

		/* 영업내 Data부 Trailer */
		fprintf( pfTran, "ATM00122%07ld%02s03 01220033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						ncount+1,
						szOrgCd			,
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );
		ncount++;

		/* 영업외 Data부 Header */
		fprintf( pfTran, "ATM00122%07ld%02s03 012300110096%04s%06s%06s%06s%*s\n",
							ncount + 1, szOrgCd, szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );
		ncount++;

		/* 시간외 데이터부 */
		/* 하나은행 공동망 일 경우  net_org_cd <> '81' 추가 */
		if( strncmp( pOrgCd, "081", 3) == 0 )
		{
			strcpy(hSQLsub,	"AND	net_org_cd <> '081' ");
		}
		sprintf(hSQLmain,
				"SELECT	DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ) AS WORK_TYPE,		" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				"		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                 		" \
				"		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                              	" \
				"		RPAD(DEAL_NO, 12, ' '),                                         	" \
				"		DEAL_STATUS                                                     	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE = '0'                                                 	" \
				"AND	DEAL_TIME_TYPE = '2'												" \
				"AND	ADMIS_ORG = 'B' 													" \
				"AND	ORG_CD = '0'||'%s'														" \
				"%s																			" ,
				szDate, szOrgCd, hSQLsub);

		EXEC SQL PREPARE SIM2 FROM :hSQLmain;
		EXEC SQL DECLARE CIM2 CURSOR FOR SIM2;
		EXEC SQL OPEN CIM2;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCommonTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetCommonTranData-%s] Error Query String [%.1024s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		nDataCnt = 0;

		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CIM2 INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CIM2;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "ATM00122%07ld%02s03 %s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%*s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									ncount+1,
									szOrgCd,
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									1	, 	" ");
			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CIM2;

		/* 영업외 Data부 Trailer */
		fprintf( pfTran, "ATM00122%07ld%02s03 01230033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						ncount+1,
						szOrgCd			,
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );

		ncount++;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetCommonTranData-%s] 전일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}

	fprintf( pfTran, "ATM001339999999%2s03%07ld%*s\n", szOrgCd, ncount, 144, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+2+2, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}


int GetKETranData(char *pTransDate, char *pOrgCd, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hWorkType[6+1];
	char	hDataType[2+1];
	char	hDealDate[10+1];
	char	hAtmDealNo[16+1];
	char	hInsetOrgCd[4+1];
	char	hInsetJijumCd[4+1];
	char	hAccountNo[25+1];

	char	hDealAmt[12+1];
	char	hCustFee[6+1];
	char	hBankFee[6+1];
	char	hOrgRespCd[2+1];
	char	hDealNo[12+1];
	char	hDealStatus[1+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];
	char	hTradeType[2+1];

	char	hFirstDate[8+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	int		nDataCnt;
	char	szContent[1024];
	char	szDate[8+1];
	char	szOrgCd[3+1];
	char	szCnt[10];

	int		nTotAcptCnt;
	long	lnTotAcptAmt;
	long	lnTotCustAmt;
	long	lnTotBankAmt;
	int		nTotCancelCnt;
	long	lnTotCancelAmt;
	int		nTotNotMngCnt;
	long	lnTotNotMngAmg;
	int		nTotRejCnt;
	long	lnTotRejAmt;

	FILE	*pfTran;

	memset( hWorkType		, 0x00, sizeof( hWorkType     ) );
	memset( hDataType       , 0x00, sizeof( hDataType     ) );
	memset( hDealDate       , 0x00, sizeof( hDealDate     ) );
	memset( hAtmDealNo      , 0x00, sizeof( hAtmDealNo    ) );
	memset( hInsetOrgCd     , 0x00, sizeof( hInsetOrgCd   ) );
	memset( hInsetJijumCd   , 0x00, sizeof( hInsetJijumCd ) );
	memset( hAccountNo      , 0x00, sizeof( hAccountNo    ) );
	memset( hDealAmt        , 0x00, sizeof( hDealAmt      ) );
	memset( hCustFee        , 0x00, sizeof( hCustFee      ) );
	memset( hBankFee        , 0x00, sizeof( hBankFee      ) );
	memset( hOrgRespCd      , 0x00, sizeof( hOrgRespCd    ) );
	memset( hDealNo         , 0x00, sizeof( hDealNo       ) );
	memset( hDealStatus     , 0x00, sizeof( hDealStatus   ) );


	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	memset(szOrgCd,		0x00, sizeof(szOrgCd));

	memset( szCnt     	, 0x00, sizeof( szCnt      	 ) );

	memcpy( szOrgCd, &pOrgCd[1], 2 );


	/* 임시.. 전송일 10일 거래일 8,9일 데이터 요청 */
	/*memcpy( hPreActDate, "20061008", 8 );*/

	/* 전송일이 휴일이면 전송일을 전송일이 영업일이면 전 영업일을 return */

	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCommonTranData-%s] 전영업일 없음. [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCommonTranData-%s] 전영업일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}


	/* 휴일에는 전송하지 않는다. */
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetCommonTranData-%s] 휴일 전송 안함 [%s]\n", szOrgCd,  pTransDate);
		return -2;
	}

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetCommonTranData-%s] 전일 없음. [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetCommonTranData-%s] 전일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetCommonTranData-%s] FileOpenError [%s]\n", pOrgCd, pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;

	while(1)
	{
		/* 영업내 Data부 Header */
		fprintf( pfTran, "012200110096%04s%06s%06s%06s%*s\n",
					szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );


		/* 시간내 데이터부 */
		sprintf(hSQLmain,
				"SELECT	DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ) AS WORK_TYPE,		" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				"		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                 		" \
				"		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                             	" \
				"		RPAD(DEAL_NO, 12, ' '),                                         	" \
				"		DEAL_STATUS                                                     	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE = '0'                                                 	" \
				"AND	DEAL_TIME_TYPE = '1'												" \
				"AND	ADMIS_ORG = 'B' 													" \
				"AND	ORG_CD = '0'||'%s'														" ,
				szDate, szOrgCd);

		EXEC SQL PREPARE SKE1 FROM :hSQLmain;
		EXEC SQL DECLARE CKE1 CURSOR FOR SKE1;
		EXEC SQL OPEN CKE1;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCommonTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetCommonTranData-%s] Error Query String [%s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}

		nDataCnt = 0;
		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CKE1 INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CKE1;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "%s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%*s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									1	, 	" ");

			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CKE1;

		/* 영업내 Data부 Trailer */
		fprintf( pfTran, "01220033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );

		/* 영업외 Data부 Header */
		fprintf( pfTran, "012300110096%04s%06s%06s%06s%*s\n",
							szOrgCd, &pTransDate[2], &hPreActDate[2], &hPreDate[2], 116, " " );


		/* 시간외 데이터부 */
		/* 하나은행 공동망 일 경우  net_org_cd <> '81' 추가 */

		sprintf(hSQLmain,
				"SELECT	DECODE(DEAL_TIME_TYPE, '1', '012200', '012300' ) AS WORK_TYPE,		" \
				"		'22' AS DATA_TYPE,                                              	" \
				"		DEAL_MMDD||DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_DATE,           	" \
				"		RPAD(DECODE(ORG_CD, '044', 											" \
				"				'96'||MAC_NO||LPAD(ATM_DEAL_NO, 6, '0'), 					" \
				"				'96'||MAC_NO||MAC_NO||LPAD(ATM_DEAL_NO, 5, '0')), 16, ' ')	" \
				"			 AS ATM_DEAL_NO, 												" \
				"		LPAD(INST_ORG_CD, 4, '0'),                                       	" \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					    		" \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,    				" \
				"		LPAD(DEAL_AMT, 12, '0') AS DEAL_AMT,                            	" \
				"		DECODE(ORG_CD, '044', DECODE(DEAL_STATUS, '0', CUST_FEE, 0), 		" \
				"											CUST_FEE) AS CUST_FEE,			" \
				"		DECODE(ORG_CD, '044', 0, BANK_FEE) AS BANK_FEE,                 		" \
				"		RPAD(RTRIM(ORG_RESPONSE_CD), 2, '9'),                              	" \
				"		RPAD(DEAL_NO, 12, ' '),                                         	" \
				"		DEAL_STATUS                                                     	" \
				"FROM	T_FN_NICE_TRAN                                                  	" \
				"WHERE	DEAL_DATE = '%s'													" \
				"AND	DEAL_TYPE = '0'                                                 	" \
				"AND	DEAL_TIME_TYPE = '2'												" \
				"AND	ADMIS_ORG = 'B' 													" \
				"AND	ORG_CD = '0'||'%s'														",
				szDate, szOrgCd);

		EXEC SQL PREPARE SKE2 FROM :hSQLmain;
		EXEC SQL DECLARE CKE2 CURSOR FOR SKE2;
		EXEC SQL OPEN CKE2;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetCommonTranData-%s] Cursor Open Error [%.200s]\n", pOrgCd, SqlErrMsg);
			logger( ">>> [GetCommonTranData-%s] Error Query String [%.1024s]\n", pOrgCd, hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		nDataCnt = 0;

		nTotAcptCnt     = 0;
		lnTotAcptAmt    = 0;
		lnTotCustAmt    = 0;
		lnTotBankAmt    = 0;
		nTotCancelCnt   = 0;
		lnTotCancelAmt  = 0;
		nTotNotMngCnt   = 0;
		lnTotNotMngAmg  = 0;
		nTotRejCnt      = 0;
		lnTotRejAmt     = 0;

		while (1)
		{
			EXEC SQL	FETCH	CKE2 INTO 	hWorkType     ,
											hDataType     ,
											hDealDate     ,
											hAtmDealNo    ,
											hInsetOrgCd   ,
											hAccountNo    ,
											hDealAmt      ,
											hCustFee      ,
											hBankFee      ,
											hOrgRespCd    ,
											hDealNo       ,
											hDealStatus   ;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CKE2;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "%s%s%06d%s%*s%s%s%.*s%*s%*s%s%0*d%0*d%*s%s%s%s%*s\n",
			/*fprintf( pfTran, "%.*s%.*s%06d%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s\n",*/
			/*fprintf( pfTran, "%.*s%.*s%.*s%*s%.*s%.*s%.*s%.*s%*s%*s%.*s%.*s%.*s%*s%.*s%.*s%.*s%*s\n",*/
									hWorkType     ,
									hDataType     ,
									nDataCnt + 1  ,
									hDealDate     ,
									6	,	" "	  ,
									hAtmDealNo    ,
									hInsetOrgCd   ,
									22, hAccountNo    ,
									4	,	" "   ,
									4	,	" "	  ,
									hDealAmt      ,
									6	,	atoi(hCustFee),
									6	,	atoi(hBankFee),
									30	,	" "			  ,
									hOrgRespCd    ,
									hDealNo       ,
									hDealStatus   ,
									1	, 	" ");
			/* 승인건수, 금액 */
			if(hDealStatus[0] == '0')
			{
				nTotAcptCnt++;
				lnTotAcptAmt    += atol(hDealAmt);
				lnTotCustAmt    += atol(hCustFee);
				lnTotBankAmt    += atol(hBankFee);
			}
			else if(hDealStatus[0] == '1') /* 취소 */
			{
				nTotCancelCnt++;
				lnTotCancelAmt  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '2') /* 미완료 */
			{
				nTotNotMngCnt ++;
				lnTotNotMngAmg  += atol(hDealAmt);
			}
			else if(hDealStatus[0] == '3') /* 거절 */
			{
				nTotRejCnt ++;
				lnTotRejAmt    += atol(hDealAmt);
			}

			nDataCnt++;
			ncount++;
	    }
		EXEC SQL CLOSE CKE2;

		/* 영업외 Data부 Trailer */
		fprintf( pfTran, "01230033  %06d%014ld%010ld%010ld%06ld%014ld%06ld%014ld%06ld%014ld%*s\n",
						nTotAcptCnt    ,
						lnTotAcptAmt   ,
						lnTotCustAmt   ,
						lnTotBankAmt   ,
						nTotCancelCnt  ,
						lnTotCancelAmt ,
						nTotNotMngCnt  ,
						lnTotNotMngAmg ,
						nTotRejCnt     ,
						lnTotRejAmt    ,
						40, " " );


		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetCommonTranData-%s] 전일 파악 실패 [%.200s]\n", pOrgCd, SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}

	fclose(pfTran);
	return 0;
}


/* 스마트카드 */
int GetSmartTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType[8+1];
	char	hRecordType[8+1];
	char	hOrgCd[10];
	char	hSmDealNo[20];
	char	hAccountNo[30];
	char	hStatusCd[10];
	char	hDealTime1[20];
	char	hDealTime2[20];
	char	hDealStatus[10];
	char	hDealAmt[20];
	char	hCustFee[20];
	char	hMacNo[20];
	char	hPreActDate[20];
	char	hPreDate[20];

	char	hDealNo[20];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	char	szAftAmt[20];

	char	szDate[8+1];
	char	szCnt[100];
	char	szPath[512];
	char	szFileName[512];

	int		ncount;
	int		nTotalCnt;
	long	lnTotalAmt;
	long	lnTotCustFee;
	int		nTotalCancelCnt;
	long	lnTotalCancelAmt;

	struct FILE_READ_DATA	suFileRead;

	FILE	*pfTran;

	memset( hDataType  , 0x00	, sizeof( hDataType   ) );
	memset( hRecordType, 0x00	, sizeof( hRecordType ) );
	memset( hOrgCd	   , 0x00	, sizeof( hOrgCd 	  ) );
	memset( hSmDealNo  , 0x00	, sizeof( hSmDealNo     ) );
	memset( hAccountNo , 0x00	, sizeof( hAccountNo  ) );
	memset( hStatusCd  , 0x00	, sizeof( hStatusCd   ) );
	memset( hDealTime1 , 0x00	, sizeof( hDealTime1  ) );
	memset( hDealTime2 , 0x00	, sizeof( hDealTime2  ) );
	memset( hDealStatus, 0x00  	, sizeof( hDealStatus ) );
	memset( hDealAmt   , 0x00  	, sizeof( hDealAmt    ) );
	memset( hCustFee   , 0x00  	, sizeof( hCustFee    ) );
	memset( hMacNo     , 0x00  	, sizeof( hMacNo      ) );

	memset( szAftAmt   , 0x00  	, sizeof( szAftAmt 	  ) );

	memset( hDealNo    , 0x00	, sizeof( hDealNo     ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	memset((char *)szPath, 	(int)0x00, sizeof(szPath));
	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)SMART_FILE_PATH, szPath ) < 0 )
	{
		logger( "GetSmartTranData : rd_cnfg_pram SMART_FILE_PATH Get Error = [%s]\n", szPath );
   		CleanUp(0);
	}

	memset(szFileName, 0x00, sizeof(szFileName));
	sprintf(szFileName, "%s/S%sDKS", szPath, pTransDate);


	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetSmartTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetSmartTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetSmartTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount			= 0;
	nTotalCnt       = 0;
	lnTotalAmt      = 0;
	lnTotCustFee       = 0;
	nTotalCancelCnt = 0;
	lnTotalCancelAmt = 0;

	/*
	fprintf( pfTran, "MDH01%*s%8s%8s%06ld%*s\n", 7+7+13+10+7+13+7+13+10+13+13+7+13,
						" ", szDate, pTransDate, GetCurTime(), 40, " " );
	*/

	fprintf( pfTran, "MDH01%*s%0*d%8s%8s%06ld%*s\n", 7+7+13+10+7+13, " ",
						7+13+10+13+13+7+13, 0, szDate, pTransDate, GetCurTime(), 40, " " );

	sprintf(hSQLmain,
			"SELECT 'MD' AS DATA_TYPE,                                             	" \
			"	    'D' AS RECORD_TYPE,                                             " \
			"		'01' AS ORG_CD,                                                 " \
			"		'0' || DEAL_DATE || '0' || SUBSTR(DEAL_NO, 7, 6) AS SMDEAL_NO,  " \
			"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					        " \
			"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,              " \
			"		'0000' AS STATUS_CD,                                            " \
			"		DEAL_DATE || DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME1,        " \
			"		DEAL_DATE || DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME2,        " \
			"		DECODE(DEAL_STATUS, '0', '5', '6') DEAL_STATUS,		 			" \
			"	   	LPAD(DEAL_AMT, 10, '0'),                                        " \
			"		LPAD(CUST_FEE, 10, '0'),                                        " \
			"		LPAD(MAC_NO, 10, '0'),						                    " \
			"		DEAL_NO															" \
			"FROM   T_FN_NICE_TRAN 										            " \
			"WHERE  DEAL_DATE = '%s' 										    	" \
			"AND	ORG_CD = '0KS' 											    	" \
			"AND    DEAL_TYPE = '8' 										        " \
			"AND	ADMIS_ORG = 'B' 												" \
			"AND    DEAL_CLSS = '3300'	                                            " ,
			szDate);

	EXEC SQL PREPARE SMR1 FROM :hSQLmain;
	EXEC SQL DECLARE CMR1 CURSOR FOR SMR1;
	EXEC SQL OPEN CMR1;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetSmartTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetSmartTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	while (1)
	{
		EXEC SQL	FETCH	CMR1 INTO 	hDataType  	,
										hRecordType	,
										hOrgCd		,
										hSmDealNo   ,
										hAccountNo 	,
										hStatusCd  	,
										hDealTime1 	,
										hDealTime2 	,
										hDealStatus	,
										hDealAmt   	,
										hCustFee   	,
										hMacNo		,
										hDealNo    	;

		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CMR1;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szAftAmt   , 0x00  	, sizeof( szAftAmt 	  ) );

		memset( &suFileRead	, 0x00	, sizeof(suFileRead) );

		memcpy( suFileRead.szDealDate, 	szDate, 	8 );
		memcpy( suFileRead.szDealNo,	hDealNo,	12);

		if( ReadSmartFileData(szFileName, &suFileRead) < 0 )
		{
			logger( ">>> [fnDBInsertUpTransDate] SmartFile Read Error [%s]\n", szFileName);
			EXEC SQL CLOSE CMR1;
			fclose(pfTran);
			return -1;
		}

		if( hDealStatus[0] == '5' )
		{
			sprintf( szAftAmt, "%010ld", atol(suFileRead.szPreAmt) + atol(hDealAmt) );
			lnTotalAmt = lnTotalAmt + atol( hDealAmt );
			lnTotCustFee = lnTotCustFee + atol(hCustFee);
			nTotalCnt++;
		}
		else
		{
			strcpy( szAftAmt, suFileRead.szPreAmt );
			lnTotalCancelAmt = lnTotalCancelAmt + atol( hDealAmt );
			nTotalCancelCnt++;
		}

		fprintf( pfTran, "%.*s%.*s%07ld%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%0*d%0*d%*s%.*s%.*s%*s\n",
								2	,	hDataType  				,
								1	,	hRecordType				,
										ncount+1				,
								2	,	hOrgCd					,
								16	,	hSmDealNo    			,
								16	,	hAccountNo 				,
								2	,	suFileRead.szOwnerType	,
								4	,	hStatusCd				,
								14	,	hDealTime1 				,
								14	,	hDealTime2 				,
								10	,	suFileRead.szDealSeqNo	,
								1	,	hDealStatus				,
								10	,	suFileRead.szPreAmt		,
								10	,	hDealAmt   				,
								10	,	szAftAmt				,
								10	,	hCustFee   				,
								10	,	0						,
								10	,	0						,
								1	,	" "						,
								10	,	hMacNo					,
								8	,	suFileRead.szConfirmNm	,
								32	,	" "						);
		ncount++;
    }
	EXEC SQL CLOSE CMR1;

	fprintf( pfTran, "MDT%*s\n", 197, " ");

	memset( szCnt, 0x00, sizeof(szCnt) );

	sprintf( szCnt, "%07ld%07ld%013ld%010ld%07ld%013ld",
					ncount, nTotalCnt, lnTotalAmt, lnTotCustFee, nTotalCancelCnt, lnTotalCancelAmt);

	fseek (pfTran, 2+1+2, 0 );
	fprintf( pfTran, "%.*s", strlen(szCnt), szCnt );

	fclose(pfTran);
	return 0;
}


/* 스마트카드 임시 (몇일단위 묶어 일괄처리)*/
int GetSmartImsiTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDataType[8+1];
	char	hRecordType[8+1];
	char	hOrgCd[10];
	char	hSmDealNo[20];
	char	hAccountNo[30];
	char	hStatusCd[10];
	char	hDealTime1[20];
	char	hDealTime2[20];
	char	hDealStatus[10];
	char	hDealAmt[20];
	char	hCustFee[20];
	char	hMacNo[20];
	char	hPreActDate[20];
	char	hPreDate[20];

	char	hDealNo[20];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	char	szAftAmt[20];

	char	szDate[8+1];
	char	szFileDate[8+1];
	char	szCnt[100];
	char	szPath[512];
	char	szFileName[512];

	int		ncount;
	int		nTotalCnt;
	long	lnTotalAmt;
	long	lnTotCustFee;
	int		nTotalCancelCnt;
	long	lnTotalCancelAmt;

	struct FILE_READ_DATA	suFileRead;

	FILE	*pfTran;

	memset( hDataType  , 0x00	, sizeof( hDataType   ) );
	memset( hRecordType, 0x00	, sizeof( hRecordType ) );
	memset( hOrgCd	   , 0x00	, sizeof( hOrgCd 	  ) );
	memset( hSmDealNo  , 0x00	, sizeof( hSmDealNo     ) );
	memset( hAccountNo , 0x00	, sizeof( hAccountNo  ) );
	memset( hStatusCd  , 0x00	, sizeof( hStatusCd   ) );
	memset( hDealTime1 , 0x00	, sizeof( hDealTime1  ) );
	memset( hDealTime2 , 0x00	, sizeof( hDealTime2  ) );
	memset( hDealStatus, 0x00  	, sizeof( hDealStatus ) );
	memset( hDealAmt   , 0x00  	, sizeof( hDealAmt    ) );
	memset( hCustFee   , 0x00  	, sizeof( hCustFee    ) );
	memset( hMacNo     , 0x00  	, sizeof( hMacNo      ) );

	memset( szAftAmt   , 0x00  	, sizeof( szAftAmt 	  ) );

	memset( hDealNo    , 0x00	, sizeof( hDealNo     ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( szFileDate	, 0x00	, sizeof(szFileDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	memset((char *)szPath, 	(int)0x00, sizeof(szPath));
	if ( rd_cnfg_parm((char *)SAM_FILE, (char *)SMART_FILE_PATH, szPath ) < 0 )
	{
		logger( "GetSmartTranData : rd_cnfg_pram SMART_FILE_PATH Get Error = [%s]\n", szPath );
   		CleanUp(0);
	}


/* 임시.. 전송일 13일 거래일 11,12일 데이터 요청 */
memcpy( hPreActDate, "20061111", 8 );


	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetSmartTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetSmartTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetSmartTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	memcpy( szFileDate, pTransDate, 8 );

	ncount			= 0;
	nTotalCnt       = 0;
	lnTotalAmt      = 0;
	lnTotCustFee       = 0;
	nTotalCancelCnt = 0;
	lnTotalCancelAmt = 0;

	/*
		fprintf( pfTran, "MDH01%*s%8s%8s%06ld%*s\n", 7+7+13+10+7+13+7+13+10+13+13+7+13,
							" ", szDate, pTransDate, GetCurTime(), 40, " " );
		*/

	fprintf( pfTran, "MDH01%*s%0*d%8s%8s%06ld%*s\n", 7+7+13+10+7+13, " ",
						7+13+10+13+13+7+13, 0, szDate, pTransDate, GetCurTime(), 40, " " );

	while(1)
	{
		sprintf(hSQLmain,
				"SELECT 'MD' AS DATA_TYPE,                                             	" \
				"	    'D' AS RECORD_TYPE,                                             " \
				"		'01' AS ORG_CD,                                                 " \
				"		'0' || DEAL_DATE || '0' || SUBSTR(DEAL_NO, 7, 6) AS SMDEAL_NO,  " \
				"		FC_FN_SECURITY(INST_JIJUM_CD, '2') || 					        " \
				"			FC_FN_SECURITY(ACCOUNT_NO, '2') AS ACCOUNT_NO,              " \
				"		'0000' AS STATUS_CD,                                            " \
				"		DEAL_DATE || DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME1,        " \
				"		DEAL_DATE || DEAL_HOUR||DEAL_MI||DEAL_SEC AS DEAL_TIME2,        " \
				"		DECODE(DEAL_STATUS, '0', '5', '6') DEAL_STATUS,		 			" \
				"	   	LPAD(DEAL_AMT, 10, '0'),                                        " \
				"		LPAD(CUST_FEE, 10, '0'),                                        " \
				"		LPAD(MAC_NO, 10, '0'),						                    " \
				"		DEAL_NO															" \
				"FROM   T_FN_NICE_TRAN 										            " \
				"WHERE  DEAL_DATE = '%s' 										    	" \
				"AND	ORG_CD = '0KS' 											    	" \
				"AND    DEAL_TYPE = '8' 										        " \
				"AND	ADMIS_ORG = 'B' 												" \
				"AND    DEAL_CLSS = '3300'	                                            " ,
				szDate);

		EXEC SQL PREPARE SMR2 FROM :hSQLmain;
		EXEC SQL DECLARE CMR2 CURSOR FOR SMR2;
		EXEC SQL OPEN CMR2;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetSmartTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetSmartTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}

		memset(szFileName, 0x00, sizeof(szFileName));
		sprintf(szFileName, "%s/S%sDKS", szPath, szFileDate);

		while (1)
		{
			EXEC SQL	FETCH	CMR2 INTO 	hDataType  	,
											hRecordType	,
											hOrgCd		,
											hSmDealNo   ,
											hAccountNo 	,
											hStatusCd  	,
											hDealTime1 	,
											hDealTime2 	,
											hDealStatus	,
											hDealAmt   	,
											hCustFee   	,
											hMacNo		,
											hDealNo    	;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CMR2;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szAftAmt   , 0x00  	, sizeof( szAftAmt 	  ) );

			memset( &suFileRead	, 0x00	, sizeof(suFileRead) );

			memcpy( suFileRead.szDealDate, 	szDate, 	8 );
			memcpy( suFileRead.szDealNo,	hDealNo,	12);

			if( ReadSmartFileData(szFileName, &suFileRead) < 0 )
			{
				logger( ">>> [fnDBInsertUpTransDate] SmartFile Read Error [%s]\n", szFileName);
				EXEC SQL CLOSE CMR2;
				fclose(pfTran);
				return -1;
			}

			if( hDealStatus[0] == '5' )
			{
				sprintf( szAftAmt, "%010ld", atol(suFileRead.szPreAmt) + atol(hDealAmt) );
				lnTotalAmt = lnTotalAmt + atol( hDealAmt );
				lnTotCustFee = lnTotCustFee + atol(hCustFee);
				nTotalCnt++;
			}
			else
			{
				strcpy( szAftAmt, suFileRead.szPreAmt );
				lnTotalCancelAmt = lnTotalCancelAmt + atol( hDealAmt );
				nTotalCancelCnt++;
			}

			fprintf( pfTran, "%.*s%.*s%07ld%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%0*d%0*d%*s%.*s%.*s%*s\n",
									2	,	hDataType  				,
									1	,	hRecordType				,
											ncount+1				,
									2	,	hOrgCd					,
									16	,	hSmDealNo    			,
									16	,	hAccountNo 				,
									2	,	suFileRead.szOwnerType	,
									4	,	hStatusCd				,
									14	,	hDealTime1 				,
									14	,	hDealTime2 				,
									10	,	suFileRead.szDealSeqNo	,
									1	,	hDealStatus				,
									10	,	suFileRead.szPreAmt		,
									10	,	hDealAmt   				,
									10	,	szAftAmt				,
									10	,	hCustFee   				,
									10	,	0						,
									10	,	0						,
									1	,	" "						,
									10	,	hMacNo					,
									8	,	suFileRead.szConfirmNm	,
									32	,	" "						);
			ncount++;
	    }
		EXEC SQL CLOSE CMR2;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetSmartImsiTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy( szFileDate, szDate, 8 );

		memcpy(szDate, hPreDate, 8);
	}

	fprintf( pfTran, "MDT%*s\n", 197, " ");

	memset( szCnt, 0x00, sizeof(szCnt) );

	sprintf( szCnt, "%07ld%07ld%013ld%010ld%07ld%013ld",
					ncount, nTotalCnt, lnTotalAmt, lnTotCustFee, nTotalCancelCnt, lnTotalCancelAmt);

	fseek (pfTran, 2+1+2, 0 );
	fprintf( pfTran, "%.*s", strlen(szCnt), szCnt );

	fclose(pfTran);
	return 0;
}


/* 하이패스 */
int GetHITranData(char *pTransDate, char *pFileName)
{
EXEC SQL BEGIN DECLARE SECTION;
	char	hWorkType[6+1];
	char	hDataType[2+1];
	char	hJijumCd[4+1];
	char	hMacNo[4+1];
	char	hMacNm[8+1];
	char	hDealNo[16+1];
	char	hDealDate[8+1];
	char	hAccountNo[16+1];
	char	hDealAmt[13+1];
	char	hDealStatus[1+1];
	char	hPreDate[8+1];
	char	hCustFee[9+1];
	char	hAccountNo2[16+1];
	char	hJoinsNo[10+1];

	char	hSQLmain[10240];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[10240];
	char	szCnt[10];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDataType	, 0x00, sizeof( hDataType	) );
	memset( hWorkType	, 0x00, sizeof( hWorkType	) );
	memset( hDealDate   , 0x00, sizeof( hDealDate   ) );
	memset( hJijumCd    , 0x00, sizeof( hJijumCd    ) );
	memset( hAccountNo  , 0x00, sizeof( hAccountNo  ) );
	memset( hMacNo      , 0x00, sizeof( hMacNo      ) );
	memset( hDealAmt    , 0x00, sizeof( hDealAmt    ) );
	memset( hDealStatus , 0x00, sizeof( hDealStatus ) );
	memset( hDealNo     , 0x00, sizeof( hDealNo     ) );
	memset( hMacNm      , 0x00, sizeof( hMacNm      ) );
	memset( szCnt     	, 0x00, sizeof( szCnt      	) );
	memset( hPreDate    , 0x00, sizeof( hPreDate    ) );
	memset( hCustFee 	, 0x00, sizeof( hCustFee  	) );
	memset( hAccountNo2 , 0x00, sizeof( hAccountNo2 ) );
	memset( hJoinsNo 	, 0x00, sizeof( hJoinsNo  	) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetHITranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}
logger("Deal_Date[%s]\n", hPreDate);

/* 하이패스의 경우 바로 전 거래( 이체요청=>기관코드 'NI' )의
   카드번호, 승인번호(제휴기관거래번호 항목을 사용), 승인일자를 같이 보낸다. */

	sprintf(hSQLmain,
			"SELECT 'V01HPS' as WORK_TYPE,																" \
			"	   '22' AS DATA_TYPE,                                                           		" \
			"	   	FC_FN_SECURITY(tran.INST_JIJUM_CD, '2') || 											" \
			"			FC_FN_SECURITY(tran.ACCOUNT_NO, '2') AS ACCOUNT_NO, 							" \
			"		tran.DEAL_DATE,																		" \
			"		tran.MAC_NO AS JIJUM_CD,															" \
			"		tran.MAC_NO,																		" \
			"		'96' || tran.MAC_NO || tran.MAC_NO || LPAD( tran.ATM_DEAL_NO, 6, '0' ) AS DEAL_NO,	" \
			"		LPAD( tran.DEAL_AMT, 13, '0' ) AS DEAL_AMT,                                      	" \
			"       SUBSTR(MAC.MAC_NM, 1, 4) AS MAC_NM,	/*한글이 1BYTE로 인식되므로*/					" \
			"		DECODE(tran.DEAL_STATUS, '0', '1', '1', '3', '2', '2', '3', '2') AS DEAL_STATUS,  	" \
			"		DECODE(tran.DEAL_STATUS, '0', LPAD(tran.CUST_FEE, 9, 0), '000000000') AS CUST_FEE,	" \
            "       FC_FN_SECURITY(T2.INST_JIJUM_CD, '2') ||                                          	" \
            "       FC_FN_SECURITY(T2.ACCOUNT_NO, '2') AS ACCOUNT_NO_2,                                 " \
            "       T2.JOIN_ORG_DEAL_NO                                                                 " \
            "FROM   T_FN_NICE_TRAN tran,                                                                " \
            "       T_FN_NICE_TRAN T2,                                                                  " \
            "       T_CM_MAC mac                                                                        " \
            "WHERE  tran.DEAL_DATE = '%s'                                                               " \
            "AND    tran.ORG_CD = '0HI'                                                                  " \
            "AND    mac.ORG_CD    = '096'                                                                " \
            "AND    mac.JIJUM_CD = '9600'                                                               " \
            "AND    tran.MAC_NO = mac.MAC_NO                                                            " \
            "AND    T2.ORG_CD = '0NI'                                                                    " \
            "AND    T2.DEAL_DATE = TRAN.DEAL_DATE                                                       " \
            "AND    T2.MAC_NO = TRAN.MAC_NO                                                             " \
            "AND    T2.ATM_DEAL_NO = LPAD(TO_NUMBER(TRAN.ATM_DEAL_NO) - 1, 5, '0')						",
			hPreDate);

	EXEC SQL PREPARE SHI1N FROM :hSQLmain;
	EXEC SQL DECLARE CHI1N CURSOR FOR SHI1N;
	EXEC SQL OPEN CHI1N;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetHITranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetHITranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}

	ncount = 0;
	lnTotalAmt = 0;

	fprintf( pfTran, "V01HPS110000000V01%08s%08s%*s\n", pTransDate, hPreDate, 116, " " );

	while (1)
	{
		EXEC SQL	FETCH	CHI1N	INTO 	hWorkType,
											hDataType,
											hAccountNo,
											hDealDate,
											hJijumCd,
											hMacNo,
											hDealNo,
											hDealAmt,
											hMacNm,
											hDealStatus,
											hCustFee,
											hAccountNo2,
											hJoinsNo;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CHI1N;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "%.*s%.*s%07ld%.*s%.*s11V01%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
								6,	hWorkType,
								2,	hDataType,
								ncount+1,
								16,	hAccountNo,
								8,	hDealDate,
								4,	hJijumCd,
								4,	hMacNo,
								16,	hDealNo,
								13,	hDealAmt,
								8,	hMacNm,
								1,	hDealStatus,
								9,  hCustFee,
								16, hAccountNo2,
								10,	hJoinsNo,
								8,	hDealDate,
								17,	" ");

		if( strcmp( hDealStatus, "1" ) == 0 )
		{
			lnTotalAmt = lnTotalAmt + atol(hDealAmt);

			ncount++;
		}
    }
	EXEC SQL CLOSE CHI1N;

	fprintf( pfTran, "V01HPS339999999V01%07ld%015ld%*s\n", ncount, lnTotalAmt, 110, " " );

	fclose(pfTran);

	return 0;
}

/* 농협카드 */
int GetCHTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[16+1];
	char	hDealAmt[12+1];
	char	hDealStatus[1+1];
	char	hDealNo[13+1];
	char	hDealNo2[6+1];
	char	hRejectCnt[8+1];
	char	hRejectAmt[8+1];
	char	hCancelCnt[8+1];
	char	hCancelAmt[8+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];

	char	hTradeType[6+1];

	char	hJoinType[2+1];
	char	hOrgRespCd[2+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
EXEC SQL END DECLARE SECTION;

	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];

	int		nTotalDealCnt;
	long	lnTotalDealAmt;
	long	lnTotalRejectAmt;
	long	nTotalRejectCnt;
	long	lnTotalCancelAmt;
	long	nTotalCancelCnt;

	FILE	*pfTran;

	memset( hDealDate   , 0x00	, sizeof( hDealDate    ) );
	memset( hDealTime   , 0x00	, sizeof( hDealTime    ) );
	memset( hAccountNo  , 0x00	, sizeof( hAccountNo   ) );
	memset( hMacNo      , 0x00	, sizeof( hMacNo       ) );
	memset( hDealAmt    , 0x00	, sizeof( hDealAmt     ) );
	memset( hDealStatus , 0x00	, sizeof( hDealStatus  ) );
	memset( hDealNo     , 0x00	, sizeof( hDealNo      ) );
	memset( hDealNo2    , 0x00	, sizeof( hDealNo2     ) );


	memset( hJoinType	, 0x00  , sizeof( hJoinType    ) );
	memset( hOrgRespCd  , 0x00  , sizeof( hOrgRespCd   ) );

	memset( hPreActDate , 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  	, 0x00	, sizeof( hPreDate   ) );

	memset( hTradeType  , 0x00	, sizeof( hTradeType   ) );

	memset( szDate		, 0x00	, sizeof(szDate) );
	memset( hFirstDate	, 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	/* 전송일이 휴일면 전송일을.. 전송일이 영업일이면 전 영업일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
			  		 						 		pkg_fn_common.sf_getPreActDate(std_date),
													std_date), std_date)
			 INTO	:hPreActDate
			 FROM 	T_FN_CALENDAR
			 WHERE 	std_date = :pTransDate;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 전영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 전영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	/*===> 휴일에도 전송하도록 이재원팀장 수정 요청 2013.04.25
	if( !memcmp(pTransDate, hPreActDate, 8 ) )
	{
		logger(">>> [GetNongHTranData][%s]-[%s] 휴일 전송 하지 않음 \n", pTransDate, hPreActDate);
		return -2;
	}
	<===*/

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetNongHTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetNongHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetNongHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	nTotalDealCnt = 0;
	lnTotalDealAmt = 0;
	nTotalRejectCnt = 0;
	lnTotalRejectAmt = 0;
	nTotalCancelCnt = 0;
	lnTotalCancelAmt = 0;

	fprintf( pfTran, "H96%8s%6ld%*s\n", pTransDate, GetCurTime(), 133, " " );

/*===> 휴일에도 전송하도록 이재원팀장 수정 요청 2013.04.25
	while(1)
	{
<===*/
		sprintf(hSQLmain,
				"SELECT DECODE( T.DEAL_STATUS, '0', '0210', '0430' ) AS TRADE_TYPE,	" \
				"		FC_FN_SECURITY(T.INST_JIJUM_CD, '2') ||						" \
				"            FC_FN_SECURITY(T.ACCOUNT_NO, '2') AS ACCOUNT_NO,		" \
				"        LPAD(T.DEAL_AMT, 11, '0') AS DEAL_AMT,						" \
				"        T.DEAL_NO,													" \
				"        SUBSTR( T.DEAL_NO, 7, 6 ) AS DEAL_NO2,						" \
				"        T.DEAL_DATE,												" \
				"        T.DEAL_HOUR||T.DEAL_MI||T.DEAL_SEC AS DEAL_TIME,			" \
				"        T.ORG_RESPONSE_CD,											" \
				"        RPAD(T.MAC_NO,16, ' ') AS MAC_NO,							" \
				"		 T.DEAL_STATUS 												" \
				"FROM    T_FN_NICE_TRAN T											" \
				"WHERE   T.DEAL_DATE = '%s'											" \
				"AND     T.ORG_CD = '0CH'											" \
				"AND     T.DEAL_TYPE = '0'   										" \
				"AND     T.DEAL_CLSS = '1300'                                       " \
				"AND     T.DEAL_STATUS IN ( '0', '1' )                              " ,
				szDate);


		EXEC SQL PREPARE SCH1 FROM :hSQLmain;
		EXEC SQL DECLARE CCH1 CURSOR FOR SCH1;
		EXEC SQL OPEN CCH1;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetNongHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetNongHTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		while (1)
		{
			EXEC SQL	FETCH	CCH1	INTO
											hTradeType,
											hAccountNo,
											hDealAmt,
											hDealNo,
											hDealNo2,
											hDealDate,
											hDealTime,
											hOrgRespCd,
											hMacNo,
											hDealStatus;
			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CCH1;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "D%.*s013008%.*s%.*s%.*s%.*s%.*s%.*s0000%.*s%.*s410%.*s%*s\n",
											4, hTradeType,
											16, hAccountNo,
											11, hDealAmt,
											12, hDealNo,
											6, hDealNo2,
											8, hDealDate,
											6, hDealTime,
											2, hOrgRespCd,
											16, hMacNo,
											1, hDealStatus,
											54, " ");

			if( strncmp( hDealStatus, "0", 1 ) == 0 )
			{
				lnTotalDealAmt = lnTotalDealAmt + atol(hDealAmt);

				nTotalDealCnt++;
			}
			else if( strncmp( hDealStatus, "1", 1 ) == 0 )
			{
				lnTotalCancelAmt = lnTotalCancelAmt + atol(hDealAmt);

				nTotalCancelCnt++;
			}
			else if( strncmp( hDealStatus, "3", 1 ) == 0 )
			{
				lnTotalRejectAmt = lnTotalRejectAmt + atol(hDealAmt);

				nTotalRejectCnt++;
			}

	    }
		EXEC SQL CLOSE CCH1;

/*===> 휴일에도 전송하도록 이재원팀장 수정 요청 2013.04.25
		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetNongHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}
<===*/

	lnTotalDealAmt /= 10000; /* 만원단위 */
	lnTotalCancelAmt /= 10000; /* 만원단위 */
	lnTotalRejectAmt /= 10000; /* 만원단위 */
	fprintf( pfTran, "T%08d%08d%08d%08d%08d%08d%*s\n",
				nTotalDealCnt, lnTotalDealAmt,
				nTotalRejectCnt, lnTotalRejectAmt,
				nTotalCancelCnt, lnTotalCancelAmt, 101, " " );

	fclose(pfTran);
	return 0;
}

int ReadSmartFileData( char * pFile, struct  FILE_READ_DATA * psuFileRead )
{
	FILE 	*fp;

	char 	szRead[1024];
	char	szDealDate[10];
	char	szDealNo[20];

	int		i;
	int		nCnt;
	int		nIndex;
	int		nColStart;


	memset( szRead, 0x00, sizeof(szRead) );

	if( (fp = fopen(pFile, "r")) == NULL )
	{
/* 임시 화일이 없을때 수작업하기 위한 임시 처리 방법
memset( psuFileRead->szOwnerType, 0x20 , 2 		);
memset( psuFileRead->szDealSeqNo, 0x20 , 10 	);
memset( psuFileRead->szPreAmt	, 0x20 , 10 	);
memset( psuFileRead->szConfirmNm, 0x20 , 8 		);
return 0;
*/
		return -1;
	}

	while( fgets(szRead, sizeof(szRead), fp) != NULL )
	{
		if( strlen(szRead) != 60 + 1) /* CR까지 */
		{
			logger( "SmartFile Length Error [%d]\n", strlen(szRead) );
			fclose(fp);
			return -1;
		}

		memset( szDealDate	, 0x00, sizeof(szDealDate	) );
		memset( szDealNo	, 0x00, sizeof(szDealNo		) );

		memcpy( szDealDate	, szRead	, 8 	);
		memcpy( szDealNo	, &szRead[8], 12 	);

		if ( !memcmp( szDealDate, psuFileRead->szDealDate, 8 ) &&
			 !memcmp( szDealNo, psuFileRead->szDealNo, 12 ) )
		{
			memcpy( psuFileRead->szOwnerType, &szRead[8+12]			, 2 	);
			memcpy( psuFileRead->szDealSeqNo, &szRead[8+12+2]		, 10 	);
			memcpy( psuFileRead->szPreAmt	, &szRead[8+12+2+10]	, 10 	);
			memcpy( psuFileRead->szConfirmNm, &szRead[8+12+2+10+10]	, 8 	);
			fclose(fp);
			return 0;
		}
		else continue;

		memset(szRead, 0x00, sizeof(szRead));
	}

	fclose(fp);

	logger( "SmartFile Data Not Found [%s-%s]\n",
				psuFileRead->szDealDate, psuFileRead->szDealNo);

	/* 해당 날자의 File은 있으나 해당 고유 번호의 데이터가 없는경우 빈칸으로 보낸다 */
	memset( psuFileRead->szOwnerType, 0x20 , 2 		);
	memset( psuFileRead->szDealSeqNo, 0x20 , 10 	);
	memset( psuFileRead->szPreAmt	, 0x20 , 10 	);
	memset( psuFileRead->szConfirmNm, 0x20 , 8 		);

	return 0;
}


/* 수협 실적 */
int GetSuHTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[8+1];
	char	hDealAmt[12+1];
	char	hDealStatus[1+1];
	char	hDealNo[13+1];

	char	hPreActDate[8+1];
	char	hPreDate[8+1];

	char	hTradeType[6+1];

	char	hJijum[3+1];
	char	hLastType[4+1];
	char	hOrgRespCd[2+1];
	char	hOrgCd[3+1];
	char	hFee[5+1];
	char	hTransOrgCd[3+1];
	char	hTransAccountNo[19+1];
	char	hAtmType[2+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];				/* sql문의 조건을 저장할*/
	EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];

	long	lnTotalAmt;

	FILE	*pfTran;

	memset( hDealDate   	, 0x00	, sizeof( hDealDate    ) );
	memset( hDealTime   	, 0x00	, sizeof( hDealTime    ) );
	memset( hAccountNo  	, 0x00	, sizeof( hAccountNo   ) );
	memset( hMacNo      	, 0x00	, sizeof( hMacNo       ) );
	memset( hDealAmt    	, 0x00	, sizeof( hDealAmt     ) );
	memset( hDealStatus 	, 0x00	, sizeof( hDealStatus  ) );
	memset( hDealNo     	, 0x00	, sizeof( hDealNo      ) );
	memset( hJijum			, 0x00	, sizeof( hJijum	   ) );
	memset( hLastType   	, 0x00  , sizeof( hLastType    ) );
	memset( hOrgRespCd  	, 0x00  , sizeof( hOrgRespCd   ) );
	memset( hOrgCd      	, 0x00  , sizeof( hOrgCd       ) );
	memset( hFee        	, 0x00  , sizeof( hFee         ) );
	memset( hTransOrgCd 	, 0x00  , sizeof( hTransOrgCd  ) );
	memset( hTransAccountNo , 0x00  , sizeof( hTransAccountNo  ) );

	memset( hPreActDate 	, 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  		, 0x00	, sizeof( hPreDate   ) );
	memset( hTradeType  	, 0x00	, sizeof( hTradeType   ) );
	memset( szDate			, 0x00	, sizeof(szDate) );
	memset( hFirstDate		, 0x00	, sizeof(hFirstDate) );
	memset(hSQLmain			, 0x00  , sizeof(hSQLmain));
	memset(hSQLsub			, 0x00  , sizeof(hSQLsub));

	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;


	memcpy(hPreActDate, hPreDate, 8);

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetSuHTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetSuHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetSuHTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;

	/* 전체 Header */
	fprintf( pfTran, "NI00011100000000070960000000%8s%*s\n", hPreDate, 164, " " );

	while(1)
	{

		sprintf(hSQLmain,
				"SELECT T.DEAL_DATE,                                                                    " \
				"           T.DEAL_HOUR||T.DEAL_MI||T.DEAL_SEC AS DEAL_TIME,                            " \
				"           '0' || T.DEAL_NO AS DEAL_NO,                                                " \
				"           '096',                                                                      " \
				"        T.MAC_NO,                                                                      " \
				"        CASE WHEN T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO = '010003' /* MS 예금인출 */    " \
				"                   THEN                                                                " \
				"                         CASE WHEN T.DEAL_TIME_TYPE = '1' /* 예금인출-시간내 */        " \
				"                                    THEN '012200'                                      " \
				"                            WHEN T.DEAL_TIME_TYPE = '2' /* 예금인출-시간외 */          " \
				"                                 THEN '012300'                                         " \
				"                            ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                  " \
				"                        END                                                            " \
				"             WHEN T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO = '010004' /* IC 예금인출 */    " \
				"                   THEN                                                                " \
				"                         CASE WHEN T.DEAL_TIME_TYPE = '1' /* 예금인출-시간내 */        " \
				"                                    THEN '012201'                                      " \
				"                            WHEN T.DEAL_TIME_TYPE = '2' /* 예금인출-시간외 */          " \
				"                                 THEN '012301'                                         " \
				"                            ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                  " \
				"                        END                                                            " \
				"            /* MS 계좌이체 */                                                          " \
				"            WHEN T.DEAL_TYPE||T.DEAL_CLSS = '400003'                                   " \
				"                 THEN                                                                  " \
				"                      /* 계좌이체 - 자행 */                                            " \
				"                     CASE WHEN (T.TRANS_ORG_CD = '0007')                               " \
				"                                     THEN                                              " \
				"                                       /* 계좌이체 - 자행이체 - 시간내 */              " \
				"                                    CASE WHEN T.DEAL_TIME_TYPE = '1'                   " \
				"                                             THEN '400000'                             " \
				"                                          /* 계좌이체 - 자행이체 - 시간외 */           " \
				"                                         WHEN T.DEAL_TIME_TYPE = '2'                   " \
				"                                             THEN '400001'                             " \
				"                                         ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO     " \
				"                                    END                                                " \
				"                            ELSE                                                       " \
				"                                    /* 계좌이체 - 타행이체 - 시간내 */                 " \
				"                                    CASE WHEN T.DEAL_TIME_TYPE = '1'                   " \
				"                                             THEN '400020'                             " \
				"                                          /* 계좌이체  - 타행이체 - 시간외 */          " \
				"                                         WHEN T.DEAL_TIME_TYPE = '2'                   " \
				"                                             THEN '400021'                             " \
				"                                         ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO     " \
				"                                    END                                                " \
				"                        END                                                            " \
				"            /* IC 계좌이체 */                                                          " \
				"            WHEN T.DEAL_TYPE||T.DEAL_CLSS = '400004'                                   " \
				"                 THEN                                                                  " \
				"                      /* 계좌이체 - 자행 */                                            " \
				"                     CASE WHEN (T.TRANS_ORG_CD = '0007')                               " \
				"                                    THEN '400100'                                      " \
				"                            ELSE '400120'                                              " \
				"                            END                                                        " \
				"                  ELSE T.DEAL_TYPE||T.DEAL_CLSS||T.TRACK_NO                            " \
				"        END AS TRADE_TYPE,                                                             " \
				"        CASE WHEN T.DEAL_STATUS = '0'                                                  " \
				"                THEN     '0200'                                                        " \
				"            WHEN T.DEAL_STATUS = '1'                                                   " \
				"                THEN '0420'                                                            " \
				"            WHEN T.DEAL_STATUS = '2'                                                   " \
				"                 THEN                                                                  " \
				"                     CASE WHEN T.DEAL_TYPE = '0'                                       " \
				"                              THEN                                                     " \
				"                                CASE WHEN T.ORG_RESPONSE_CD = '11'                     " \
				"                                        THEN '0420'                                    " \
				"                                ELSE '0200'                                            " \
                "                                END                                                    " \
				"                         WHEN T.DEAL_TYPE = '4'                                        " \
				"                            THEN '0200'                                                " \
                "                         ELSE     '0200'                                               " \
				"                    END                                                                " \
				"             WHEN T.DEAL_STATUS = '3'                                                  " \
               	"                   THEN                                                                " \
               	"                        CASE WHEN T.DEAL_TYPE = '0'                                    " \
               	"                              THEN                                                     " \
               	"                                     CASE WHEN T.REFUSE_CD = '608'                     " \
               	"                                              THEN '0420'                              " \
               	"                                            ELSE                                       " \
               	"                                                   CASE WHEN T.ORG_RESPONSE_CD <> '11' " \
               	"                                                                 THEN '0200'           " \
				"                                                           ELSE '0200'                 " \
				"                                                 END                                   " \
				"                                       END                                             " \
				"                             WHEN T.DEAL_TYPE = '4'                                    " \
                "                                    THEN '0200'                                        " \
                "                             ELSE  '0200'                                              " \
                "                                 END                                                   " \
                "            ELSE   '0200'                                                              " \
                "        END AS LAST_TYPE,                                                              " \
                "        ORG_RESPONSE_CD,                                                               " \
                "        CASE WHEN (ASCII(SUBSTR(T.ORG_CD, 2, 1)) >= 48 AND                             " \
				"                        ASCII(SUBSTR(T.ORG_CD, 2, 1)) <= 57)                           " \
				"                   AND (ASCII(SUBSTR(T.ORG_CD, 3, 1)) >= 48 AND                        " \
				"                           ASCII(SUBSTR(T.ORG_CD, 3, 1)) <= 57)                        " \
				"                  THEN SUBSTR(T.ORG_CD, 1, 3)                                          " \
				"             ELSE '096'                                                                " \
				"        END AS ORG_CD,                                                                 " \
				"        FC_FN_SECURITY(T.REAL_ACCOUNT_NO, '2') AS ACCOUNT_NO,                          " \
				"        LPAD(T.DEAL_AMT, 12, '0') AS DEAL_AMT,                                         " \
				"        LPAD(T.CUST_FEE, 5, '0') AS FEE,                                               " \
				"        SUBSTR(NVL(T.TRANS_ORG_CD, '0000'), 2, 3),                                     " \
				"        FC_FN_SECURITY(T.TRANS_JIJUM_CD, '2') ||                                       " \
				"        FC_FN_SECURITY(T.TRANS_ACCOUNT_NO, '2') AS TRANS_ACCOUNT_NO                    " \
				"FROM    T_FN_NICE_TRAN T,                                                              " \
				"        T_CT_NICE_MAC  M,                                                              " \
				"        T_CM_MAC       C                                                               " \
				"WHERE    T.MAC_NO = M.MAC_NO                                                           " \
				"AND    T.DEAL_DATE = '%s'                                                        		" \
				"AND    C.MAC_NO = T.MAC_NO                                                             " \
				"AND    C.JIJUM_CD = '9600'                                                             " \
				"AND    T.ORG_CD = '007'                                                                " \
				"AND    T.DEAL_STATUS = '0'                                                             " \
				"AND    T.DEAL_TYPE IN ('0', '4')                                                       " \
				"AND    C.ORG_CD = '096'																",
				szDate);

		EXEC SQL PREPARE SSUH FROM :hSQLmain;
		EXEC SQL DECLARE CSUH CURSOR FOR SSUH;
		EXEC SQL OPEN CSUH;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetSuHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetSuHTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		while (1)
		{
			EXEC SQL	FETCH	CSUH	INTO 	hDealDate,
											hDealTime,
											hDealNo,
											hJijum,
											hMacNo,
											hTradeType,
											hLastType,
											hOrgRespCd,
											hOrgCd,
											hAccountNo,
											hDealAmt,
											hFee,
											hTransOrgCd,
											hTransAccountNo;
			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CSUH;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "NI000122%07ld", ncount+1 );
			fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
					8, hDealDate,	6, hDealTime, 13, hDealNo,
					3, hJijum, 4, hMacNo, 6, hTradeType,
					4, hLastType, 2, hOrgRespCd, 3, hOrgCd, 16, hAccountNo,
					12, hDealAmt, 5, hFee, 3, hTransOrgCd, 14, hTransAccountNo,
					86, " ");

			lnTotalAmt = lnTotalAmt + atol(hDealAmt);

			ncount++;
	    }
		EXEC SQL CLOSE CSUH;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetSuHTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}


	fprintf( pfTran, "NI0001339999999007096%07ld%*s%*s\n", ncount, 8, pTransDate, 164, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+3+3, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
}



/* 수협 기기정보 */
int GetSuHMacData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hMacNo[4+1];
	char	hType[1+1];
	char	hSetPlace[30+1];
	char	hSetAddr[100+1];
	char	hInterphoneNo[15+1];
	char	hZipNo[6+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];			/* sql문의 조건을 저장할*/
	EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];
	char	hActDate[8+1];

	FILE	*pfTran;

	memset( hType         , 0x00	, sizeof( hType         ) );
	memset( hMacNo        , 0x00	, sizeof( hMacNo         ) );
	memset( hSetPlace     , 0x00	, sizeof( hSetPlace      ) );
	memset( hSetAddr      , 0x00	, sizeof( hSetAddr       ) );
	memset( hInterphoneNo , 0x00	, sizeof( hInterphoneNo  ) );
	memset( hZipNo        , 0x00	, sizeof( hZipNo         ) );
	memset( hActDate 	  , 0x00	, sizeof( hActDate   ) );
	memset( szDate		  , 0x00	, sizeof(szDate) );
	memset( hFirstDate	  , 0x00	, sizeof(hFirstDate) );

	memset(hSQLmain, 	0x00, sizeof(hSQLmain));
	memset(hSQLsub,		0x00, sizeof(hSQLsub));

	/* 매월 첫일이 휴일면 익영업일을.. 그렇지 않으면 전송일을 return */
	EXEC SQL SELECT decode(holiday_yn, '0', decode(real_holiday_yn, '0',
                                                        std_date,
                                                    pkg_fn_common.sf_getPostActDate(std_date)),
                                                    pkg_fn_common.sf_getPostActDate(std_date))
             INTO	hActDate
             FROM     T_FN_CALENDAR
             WHERE     std_date = substr( :pTransDate, 1, 6) || '01';

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetSuHMacData] 익영업일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetSuHMacData] 익영업일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	/* 휴일에는 전송하지 않는다. */
	if( memcmp(pTransDate, hActDate, 8 ) != 0  )
	{
		logger(">>> [GetSuHMacData][%s]-[%s] 휴일 전송 하지 않음, 매달 첫 영업일에만 전송 \n", pTransDate, hActDate);
		return -2;
	}


 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetSuHMacData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	ncount = 0;

	fprintf( pfTran, "NI00021100000000070960000000%8s%*s\n", pTransDate, 164, " " );

	sprintf(hSQLmain,
			"SELECT  MAC.MAC_NO,                                                 	" \
			"		 'J',														    " \
			"        SUBSTR(SITE.SITE_NM, 1, 13),                                	" \
			"        SUBSTR(SITE.SET_ADDR, 1, 48),                                 	" \
			"		 '1577-4655',													" \
			"        SITE.ZIP_NO                                                	" \
			"FROM    T_CM_MAC        MAC,                                        	" \
			"        T_CM_SITE       SITE,                                       	" \
			"        T_CT_NICE_MAC   NMAC                                        	" \
			"WHERE   MAC.ORG_CD = '096'                                           	" \
			"AND     MAC.JIJUM_CD = '9600'                                       	" \
			"AND     MAC.ORG_CD = SITE.ORG_CD                                    	" \
			"AND     MAC.JIJUM_CD = SITE.JIJUM_CD                                	" \
			"AND     MAC.SITE_CD = SITE.SITE_CD                                  	" \
			"AND     MAC.MAC_NO = NMAC.MAC_NO                                    	" \
			"AND	 MAC.MAC_NO < 'A000'										    " \
			"AND     ( MAC.CLOSE_DATE IS NULL OR MAC.CLOSE_DATE >= '%s' )  			",
			pTransDate, pTransDate);

	EXEC SQL PREPARE SSUH2 FROM :hSQLmain;
	EXEC SQL DECLARE CSUH2 CURSOR FOR SSUH2;
	EXEC SQL OPEN CSUH2;

	if( sqlca.sqlcode )
	{
		logger( ">>> [GetSuHTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
		logger( ">>> [GetSuHTranData] Error Query String [%.1024s]\n", hSQLmain);
		fclose(pfTran);
		return	-1;
	}


	while (1)
	{
		EXEC SQL	FETCH	CSUH2	INTO 	hMacNo,
											hType,
											hSetPlace,
											hSetAddr,
											hInterphoneNo,
											hZipNo;
		if(sqlca.sqlcode == DB_NO_DATA)
		{
			break;
		}
		else if(sqlca.sqlcode == -1405)
		{
			/* 정상처리
			logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
			*/
		}
		else if(sqlca.sqlcode)
		{
			logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
			EXEC SQL CLOSE CSUH2;
			fclose(pfTran);
			return -1;
		}

		EXEC ORACLE OPTION (HOLD_CURSOR=YES);
		/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

		EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

		memset( szContent, 0x00, sizeof(szContent) );

		fprintf( pfTran, "NI000222%07ld096", ncount+1 );
		fprintf( pfTran, "%.*s%.*s%.*s%.*s%.*s%.*s%*s\n",
				4, hMacNo, 1, hType,	30, hSetPlace, 100, hSetAddr,
				15, hInterphoneNo, 6, hZipNo, 26, " ");

		ncount++;
    }
	EXEC SQL CLOSE CSUH2;

	fprintf( pfTran, "NI0002339999999007096%07ld%.8s%*s\n", ncount, pTransDate, 164, " " );

	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+3+3, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
	return 0;
}

/* 금융결제원(KFTC) 실적 */
int GetKFTCTranData(char *pTransDate, char *pFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hDealDate[8+1];
	char	hDealTime[6+1];
	char	hAccountNo[25+1];
	char	hMacNo[8+1];
	char	hDealAmt[15+1];
	char	hDealStatus[1+1];
	char	hDealNo[13+1];
	char	hActDate[8+1];
	char	hPreActDate[8+1];
	char	hPreDate[8+1];

	char	hTradeType[6+1];
	char	hDebitCd[1+1];
	char	hJijum[3+1];
	char	hLastType[4+1];
	char	hOrgRespCd[2+1];
	char	hOrgCd[3+1];
	char	hFee[5+1];
	char	hTransOrgCd[3+1];
	char	hTransAccountNo[19+1];
	char	hAtmType[2+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	char	hSQLsub[256];				/* sql문의 조건을 저장할*/
	EXEC SQL END DECLARE SECTION;

	int		ncount;
	char	szContent[1024];
	char	szDate[8+1];
	char	szCnt[10];
	char	hFirstDate[8+1];

	long	lnTotalAmt;
	unsigned long	nTotalDebitAmt = 0;
	unsigned long	nTotalCreditAmt = 0;

	FILE	*pfTran;

	memset( hDealDate   	, 0x00	, sizeof( hDealDate    ) );
	memset( hDealTime   	, 0x00	, sizeof( hDealTime    ) );
	memset( hAccountNo  	, 0x00	, sizeof( hAccountNo   ) );
	memset( hMacNo      	, 0x00	, sizeof( hMacNo       ) );
	memset( hDealAmt    	, 0x00	, sizeof( hDealAmt     ) );
	memset( hDealStatus 	, 0x00	, sizeof( hDealStatus  ) );
	memset( hDealNo     	, 0x00	, sizeof( hDealNo      ) );
	memset( hJijum			, 0x00	, sizeof( hJijum	   ) );
	memset( hLastType   	, 0x00  , sizeof( hLastType    ) );
	memset( hOrgRespCd  	, 0x00  , sizeof( hOrgRespCd   ) );
	memset( hOrgCd      	, 0x00  , sizeof( hOrgCd       ) );
	memset( hFee        	, 0x00  , sizeof( hFee         ) );
	memset( hTransOrgCd 	, 0x00  , sizeof( hTransOrgCd  ) );
	memset( hTransAccountNo , 0x00  , sizeof( hTransAccountNo  ) );

	memset( hActDate  		, 0x00	, sizeof( hActDate   ) );
	memset( hPreActDate 	, 0x00	, sizeof( hPreActDate   ) );
	memset( hPreDate  		, 0x00	, sizeof( hPreDate   ) );
	memset( hTradeType  	, 0x00	, sizeof( hTradeType   ) );
	memset( szDate			, 0x00	, sizeof(szDate) );
	memset( hFirstDate		, 0x00	, sizeof(hFirstDate) );
	memset(hSQLmain			, 0x00  , sizeof(hSQLmain));
	memset(hSQLsub			, 0x00  , sizeof(hSQLsub));

	/* 영업일엔 영업일을 반환, 휴일에는 최종영업일을 반환 				*/
	EXEC SQL SELECT Decode(holiday_yn, '1', pkg_fn_common.sf_getPreActDate(std_date), std_date)
			INTO	:hActDate
			FROM	t_fn_calendar
			where	std_date = :pTransDate;
/*
	EXEC SQL SELECT Decode(holiday_yn, '1', pkg_fn_common.sf_getPreActDate(std_date), std_date)

			INTO :hActDate
			FROM t_fn_calendar

			WHERE std_Date = :pTransDate;
*/
    if ( sqlca.sqlcode == DB_NO_DATA ) {
    	logger(">>> [GetKFTCTranData] 영업일 없음. [%.200s]\n", SqlErrMsg);
    	return -1;
    } else if ( sqlca.sqlcode ) {
    	logger(">>> [GetKFTCTranData] 영업일 파악 실패. [%.200s]\n", SqlErrMsg);
    	return -1;
    }

	/* 휴일에는 전송하지 않는다.					 */
	/* 값이 다를 경우, 함수 종료.					*/
	if( memcmp(pTransDate, hActDate, 8 ) != 0  )
	{
		logger(">>> [GetKFTCTranData][%s]-[%s] 휴일 전송 하지 않음, 영업일에만 전송 \n", pTransDate, hActDate);
		return -2;
	}


	EXEC SQL SELECT TO_CHAR(TO_DATE(:pTransDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
			 INTO	:hPreDate
			 FROM 	DUAL;


	memcpy(hPreActDate, hPreDate, 8);

	if(sqlca.sqlcode == DB_NO_DATA)
	{
		logger(">>> [GetKFTCTranData] 전일 없음. [%.200s]\n", SqlErrMsg);
		return -1;
	}
	else if( sqlca.sqlcode )
	{
		logger(">>> [GetKFTCTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

 	if(( pfTran = fopen( pFileName, "w" )) == NULL )
	{
		logger( ">>> [GetKFTCTranData] FileOpenError [%s]\n", pFileName);
		return -1;
	}

	memcpy( szDate, hPreDate, 8 );

	ncount = 0;

	/* 전체 Header */
	fprintf( pfTran, "CD111911%07d096*******%8s%*s\n", ncount, pTransDate, 67, " " );

	while(1)
	{

		sprintf(hSQLmain,
				"SELECT orgCode, DECODE(orgCode,'004', 'C',DECODE(SIGN(demandAmt), -1, 'C','D')) 					" \
               	"	    ,TO_CHAR(ABS(demandAmt), 'FM000000000000000')               								"\
		        "FROM (SELECT NVL(org.org_cd, '004')   orgCode,                     								"\
		        "             NVL(SUM(demand_amt), 0)  demandAmt                    								"\
		        "      FROM (SELECT org_cd                                          								"\
		        "            FROM t_cm_org                                          								"\
		        "            WHERE tran_yn      = '0'                               								"\
		        "              AND org_cd  NOT IN ('004','0MS')                     								"\
		        "              AND nice_org_yn IN ('0', '1', '2')                   								"\
		        "           ) org,                                                  								"\
		        "           (SELECT org2.kftc_org_cd org_cd,dmd.demand_amt          								"\
		        "            FROM (SELECT org_cd, demand_amt                        								"\
		        "                  FROM t_fn_nice_demand                            								"\
		        "                  WHERE demand_date ='%s'                        									"\
		        "                  UNION ALL                                        								"\
		        "                  SELECT org_cd, 																	"\
		        "                         DECODE(org_cd,'071',0,'007',0,'011',0,'012',0,'032',0,'031',0,demand_amt)"\
		        "                  FROM t_fn_pack_demand                           									"\
		        "                  WHERE demand_date ='%s'                         									"\
		        "                  union all                                       									"\
		        "                  SELECT '088', cash_amt * (-1)                   									"\
		        "                  FROM t_fn_carry                                 									"\
		        "                  WHERE carry_date = '%s'                     											"\
		        "                     and carry_group_cd ='04'                     									"\
		        "                     and carry_org_cd='1030401'                   									"\
		        "                     ) dmd, 	             															"\
				"                  t_cm_org org2                                   									"\
				"            WHERE org2.org_cd = dmd.org_cd                        									"\
		        "           ) opr                                                  									"\
		        "      WHERE org.org_cd = opr.org_cd (+)                           									"\
		        "      GROUP BY ROLLUP(org.org_cd))                                									"\
		        "ORDER BY orgCode                                             										 ",
		        pTransDate, pTransDate, pTransDate);

		EXEC SQL PREPARE SKFTC FROM :hSQLmain;
		EXEC SQL DECLARE CKFTC CURSOR FOR SKFTC;
		EXEC SQL OPEN CKFTC;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetKFTCTranData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetKFTCTranData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}


		while (1)
		{
			EXEC SQL	FETCH	CKFTC	INTO 	hOrgCd, hDebitCd, hDealAmt;
			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CKFTC;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);

			memset( szContent, 0x00, sizeof(szContent) );

			fprintf( pfTran, "CD111922%07d%s%s%015ld%*s\n", ncount+1, hOrgCd ,hDebitCd, atol(hDealAmt), 66, " " );

			/* 차변과 대변 각각 총합을 구함 */
			if ( strcmp( hDebitCd , "D" ) == 0 ) { 					/* 차변일 경우 */
				nTotalDebitAmt = nTotalDebitAmt + atol(hDealAmt);
			} else {/*	if ( strcmp( hDebitCD , "C" ) == 0 )	*/ /* 대변일 경우 */
				nTotalCreditAmt = nTotalCreditAmt + atol(hDealAmt);
			}

			ncount++;
	    }
		EXEC SQL CLOSE CKFTC;

		EXEC SQL SELECT TO_CHAR(to_date(:szDate, 'YYYYMMDD') - 1, 'YYYYMMDD')
				 INTO	:hPreDate
				 FROM 	DUAL;

		if( sqlca.sqlcode )
		{
			logger(">>> [GetKFTCTranData] 전일 파악 실패 [%.200s]\n", SqlErrMsg);
			fclose(pfTran);
			return -1;
		}

		if( atol(hPreDate) < atol(hPreActDate) )
		{
			break;
		}

		memcpy(szDate, hPreDate, 8);
	}


	fprintf( pfTran, "CD1119339999999096%07d%020lu%020lu%*s\n", ncount, nTotalDebitAmt, nTotalCreditAmt, 35, " " );


	memset( szCnt, 0x00, sizeof(szCnt) );
	sprintf( szCnt, "%07ld", ncount );
	fseek (pfTran, 6+2+7+3, 0 );
	fprintf( pfTran, "%7s", szCnt );

	fclose(pfTran);
}

#define MAX_MAIN_INDEX	8
#define MAX_SUB_INDEX	8
/* 전자상품권 코드정보 */
int GetGiftCardInfoData(char *pTransDate, char *pPathName, char * pRtnFileName)
{
	EXEC SQL BEGIN DECLARE SECTION;
	char	hInfoType[1+1];
	char	hCol_2[100];
	char	hCol_3[100];
	char	hCol_4[100];
	char	hCol_5[100];
	char	hCol_6[100];
	char	hCol_7[100];
	char	hCol_8[100];
	char	hCol_9[100];
	char	hCol_10[100];

	char	hNextDate[6+1];

	char	hSQLmain[20480];			/* 다이나믹 SQL에 사용할 쿼리 메인 */
	EXEC SQL END DECLARE SECTION;

	FILE	*pfTran;

	char	szFileName[512];

	memset( hInfoType   	, 0x00	, sizeof( hInfoType    ) );
	memset( hCol_2			  , 0x00	, sizeof( hCol_2  ) );
	memset( hCol_3			  , 0x00	, sizeof( hCol_3  ) );
	memset( hCol_4			  , 0x00	, sizeof( hCol_4  ) );
	memset( hCol_5			  , 0x00	, sizeof( hCol_5  ) );
	memset( hCol_6			  , 0x00	, sizeof( hCol_6  ) );
	memset( hCol_7			  , 0x00	, sizeof( hCol_7  ) );
	memset( hCol_8  		  , 0x00	, sizeof( hCol_8  ) );
	memset( hCol_9			  , 0x00  , sizeof( hCol_9  ) );
	memset( hCol_10			  , 0x00  , sizeof( hCol_10  ) );

	memset(hSQLmain			, 0x00  , sizeof(hSQLmain));
	memset(hNextDate		, 0x00  , sizeof(hNextDate));
	memset(szFileName		, 0x00  , sizeof(szFileName));

	EXEC SQL SELECT TO_CHAR(sysdate + 1, 'YYMMDD')
				 INTO	:hNextDate
				 FROM 	DUAL;

	if( sqlca.sqlcode )
	{
		logger(">>> [GetKFTCTranData] 익일 파악 실패 [%.200s]\n", SqlErrMsg);
		return -1;
	}

	sprintf(pRtnFileName, "gvinfo_%s.txt", hNextDate);

	sprintf(szFileName, "%s/%s", pPathName, pRtnFileName);


 	if(( pfTran = fopen( szFileName, "w" )) == NULL )
	{
		logger( ">>> [GetKFTCTranData] FileOpenError [%s]\n", szFileName);
		return -1;
	}

		sprintf(hSQLmain,
							"select GIFT_INFO.COL_1,																		" \
							"		GIFT_INFO.COL_2,  																		" \
							"		GIFT_INFO.COL_3,  																		" \
							"		GIFT_INFO.COL_4,  																		" \
							"		GIFT_INFO.COL_5,  																		" \
							"		GIFT_INFO.COL_6,  																		" \
							"		GIFT_INFO.COL_7,  																		" \
							"		GIFT_INFO.COL_8,  																		" \
							"		GIFT_INFO.COL_9,  																		" \
							"		decode(length(GIFT_INFO.COL_10), 1, GIFT_INFO.COL_10,                                   " \
					        "                    substr(GIFT_INFO.COL_10, 2, 1)) as COL_10	                                " \
					        "from (                                                                 						" \
					        "        select '0'                   as COL_1,   /*대_소구분     */    						" \
					        "               NVL(MAIN.USE_YN, '0') as COL_2,   /*사용여부      */    						" \
					        "               MAIN.GIFT_INITIAL     as COL_3,   /*발급사이니셜  */    						" \
					        "               MAIN.GIFT_JUM_CD      as COL_4,   /*점포코드    */    							" \
					        "               MAIN.ISSUE_COM_CD     as COL_5,   /*발급사코드    */    						" \
					        "               MAIN.GIFT_NM          as COL_6,   /*발급사명      */    						" \
					        "               MAIN.MSG              as COL_7,   /*안내멘트      */    						" \
					        "               ''                    as COL_8,                         						" \
					        "               ''                    as COL_9,                         						" \
					        "               TO_CHAR(MAIN.DISP_ORDER)       as COL_10   /*버튼순서      */    				" \
					        "        from T_CM_GIFT    main                                       							" \
					        "        where NVL(MAIN.USE_YN, '0') = '1'                           							" \
					        "        UNION ALL                                                      						" \
					        "        select '1'                                      as COL_1,   /* 대_소구분    */ 		" \
					        "               SUB.GIFT_INITIAL                         as COL_2,   /* 발급사이니셜 */ 		" \
					        "               SUB.GIFT_JUM_CD                          as COL_3,   /* 점포코드 	 */ 		" \
					        "               NVL(SUB.USE_YN, '0')                     as COL_4,   /* 사용여부     */ 		" \
					        "               SUB.GIFT_SUB_CD                          as COL_5,   /* 세분류코드   */ 		" \
					        "               SUB.GIFT_SUB_NM                          as COL_6,   /* 세분류명     */ 		" \
					        "               TO_CHAR(NVL(SUB.GIFT_SAIL_AMT, 0))       as COL_7,   /* 판매금액     */ 		" \
					        "               TO_CHAR( NVL(SUB.IC_PROFIT_RATE, 0))     as COL_8,   /* 현금IC마진율 */ 		" \
					        "               TO_CHAR(NVL(SUB.CASH_PROFIT_RATE, 0))    as COL_9,   /* 현금마진율   */ 		" \
					        "               TO_CHAR(MAIN.DISP_ORDER)||TO_CHAR(SUB.DISP_ORDER) as COL_10   /* 버튼순서     */" \
					        "        from  T_CM_GIFT           MAIN,                                     					" \
					        "              T_CM_GIFT_DETAIL    SUB                                       					" \
					        "        where NVL(MAIN.USE_YN, '0') = '1'                              						" \
					        "        and   NVL(SUB.USE_YN, '0') = '1'                              							" \
					        "        AND   MAIN.GIFT_INITIAL = SUB.GIFT_INITIAL                                             " \
					        "        AND   MAIN.GIFT_JUM_CD = SUB.GIFT_JUM_CD                                               " \
					        "        ) GIFT_INFO                                                    						" \
					        "order by GIFT_INFO.col_10                                                                      " );


		EXEC SQL PREPARE SGV FROM :hSQLmain;
		EXEC SQL DECLARE CGV CURSOR FOR SGV;
		EXEC SQL OPEN CGV;

		if( sqlca.sqlcode )
		{
			logger( ">>> [GetGiftCardInfoData] Cursor Open Error [%.200s]\n", SqlErrMsg);
			logger( ">>> [GetGiftCardInfoData] Error Query String [%.1024s]\n", hSQLmain);
			fclose(pfTran);
			return	-1;
		}

		int nMainIdex = 0;
		int	nSubIdex = 0;
		int i;

		while (1)
		{
			EXEC SQL	FETCH	CGV	INTO 	hInfoType,
																hCol_2,
																hCol_3,
																hCol_4,
																hCol_5,
																hCol_6,
																hCol_7,
																hCol_8,
																hCol_9,
																hCol_10;

			if(sqlca.sqlcode == DB_NO_DATA)
			{
				break;
			}
			else if(sqlca.sqlcode == -1405)
			{
				/* 정상처리
				logger( ">>> [fnDBInsertUpTransDate] Select NULL Continue [%.200s]\n", SqlErrMsg);
				*/
			}
			else if(sqlca.sqlcode)
			{
				logger( ">>> [fnDBInsertUpTransDate] Fetch Error [%.200s]\n", SqlErrMsg);
				EXEC SQL CLOSE CGV;
				fclose(pfTran);
				return -1;
			}

			EXEC ORACLE OPTION (HOLD_CURSOR=YES);
			/*EXEC ORACLE OPTION (RELEASE_CURSOR=NO);*/

			EXEC ORACLE OPTION (RELEASE_CURSOR=YES);


			spc_chk0( strlen( hInfoType ), hInfoType );
			spc_chk0( strlen( hCol_2 		), hCol_2 	 );
			spc_chk0( strlen( hCol_3 		), hCol_3 	 );
			spc_chk0( strlen( hCol_4 		), hCol_4 	 );
			spc_chk0( strlen( hCol_5 		), hCol_5 	 );
			spc_chk0( strlen( hCol_6 		), hCol_6 	 );
			spc_chk0( strlen( hCol_7 		), hCol_7 	 );
			spc_chk0( strlen( hCol_8 		), hCol_8 	 );
			spc_chk0( strlen( hCol_9 		), hCol_9 	 );
			spc_chk0( strlen( hCol_10 		), hCol_10 	 );


			int nQryIndex = atoi(hCol_10) - 1;

			/* 대분류 일경우 포맷 */
			if( strcmp( hInfoType, "0" ) == 0 )
			{
				/* 세분류가 8개이하로 정의 되어 있다면 빈칸을 넣어주기 위한 작업 */
				if( nMainIdex > 0 && nSubIdex < MAX_SUB_INDEX )
				{
					for( i = nSubIdex; i < MAX_SUB_INDEX ; i++ )
					{
						fprintf( pfTran, "1       0%*s\n", 141, " ");
					}
				}

				if( nMainIdex  <= nQryIndex )
				{
					while( 1 )
					{
						if( nMainIdex == nQryIndex )
						{
							fprintf( pfTran, "0%-*s%-*s%-*s%-*s%-*s%-*s%*s\n",  1, "1", 3,hCol_3, 4,hCol_4, 2,hCol_5, 20,hCol_6, 80,hCol_7, 39, " " );
							break;
						}
						else
						{
							fprintf( pfTran, "00%*s\n", 148, " ");

							for( i = 0; i < MAX_SUB_INDEX; i++ )
							{
								fprintf( pfTran, "1       0%*s\n", 141, " ");
							}

							nMainIdex++;

							if( nMainIdex == MAX_MAIN_INDEX ) break;
						}

					}
				}

				nMainIdex++;

				nSubIdex = 0;

			}
			/* 세부분류 일경우 포맷 */
			else
			{

				char szImsi1[10], szImsi2[10];
				memset( szImsi1, 0x00, sizeof( szImsi1 ) );
				memset( szImsi2, 0x00, sizeof( szImsi2 ) );

				sprintf( szImsi1, "%02.02f", atof(hCol_8) );
				sprintf( szImsi2, "%02.02f", atof(hCol_9) );

				if( nSubIdex  <= nQryIndex )
				{
					while( 1 )
					{
						if( nSubIdex == nQryIndex )
						{
							fprintf( pfTran, "1%-*s%-*s%-*s%-*s%-*s%07d%0*s%0*s%*s\n",  3,hCol_2, 4,hCol_3, 1, "1", 2,hCol_5, 20,hCol_6, atoi(hCol_7), 5, szImsi1, 5, szImsi2, 102, " " );
							break;
						}
						else
						{
							fprintf( pfTran, "1       0%*s\n", 141, " ");

							nSubIdex++;
						}

						if( nSubIdex == MAX_SUB_INDEX ) break;
					}
				}

				nSubIdex++;
			}

			memset( hInfoType   	, 0x00	, sizeof( hInfoType    ) );
			memset( hCol_2			  , 0x00	, sizeof( hCol_2  ) );
			memset( hCol_3			  , 0x00	, sizeof( hCol_3  ) );
			memset( hCol_4			  , 0x00	, sizeof( hCol_4  ) );
			memset( hCol_5			  , 0x00	, sizeof( hCol_5  ) );
			memset( hCol_6			  , 0x00	, sizeof( hCol_6  ) );
			memset( hCol_7			  , 0x00	, sizeof( hCol_7  ) );
			memset( hCol_8  		  , 0x00	, sizeof( hCol_8  ) );
			memset( hCol_9			  , 0x00  , sizeof( hCol_9  ) );
			memset( hCol_10			  , 0x00  , sizeof( hCol_10  ) );
	}

	/* 쿼리 종료후 채워지지않은 필드 채우기 */
	if( nSubIdex < MAX_SUB_INDEX )
	{
		for( i = nSubIdex; i < MAX_SUB_INDEX ; i++ )
		{
			fprintf( pfTran, "1       0%*s\n", 141, " ");
		}
	}

	if( nMainIdex < MAX_MAIN_INDEX )
	{
		while( nMainIdex < MAX_MAIN_INDEX )
		{
			fprintf( pfTran, "00%*s\n", 148, " ");
			for( i = 0; i < MAX_SUB_INDEX; i++ )
			{
				fprintf( pfTran, "1       0%*s\n", 141, " ");
			}
			nMainIdex ++;
		}
	}

	EXEC SQL CLOSE CGV;

	fclose(pfTran);
}
